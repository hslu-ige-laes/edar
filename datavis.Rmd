# Data Visualizations
## Room Temperature Reduction
### Task
As part of an energy optimization, you lower the room temperatures in a room and would now like to show the reduction effect using the time series of the room temperature sensor. In the example below you make two optimizations at different dates.

You want to create a time series plot with

* the daily median, min and max value

* the overall median of each period

* the desired setpoint

### Basis

* Time series data from e.g. a temperature sensor with unaligned time intervals

### Solution

```{r tempreduction, warning=FALSE, message=FALSE, collapse = FALSE}
library(dplyr)
library(lubridate)
library(dygraphs)
library(xts)
library(redutils)
library(RColorBrewer)

# Settings
tempSetpoint = 22.0

startDate = "2018-11-01"
endDate = "2019-02-01"

optiDate1 = "2018-12-17"
optiLabel1 = "Optimization I"

optiDate2 = "2019-01-03"
optiLabel2 = "Optimization II"

optiDelayDays = 5

# read and print data
data <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv",
                 stringsAsFactors=FALSE,
                 sep =";")

# select temperature and remove empty cells
data <- data %>% select(time, FlatA_Temp) %>% na.omit()

# create column with day for later grouping
data$time <- parse_date_time(data$time, "YmdHMS", tz = "Europe/Zurich")
data$day <- as.Date(cut(data$time, breaks = "day"))
data$day <- as.Date(as.character(data$day,"%Y-%m-%d"))

# filter time range
data <- data %>% filter(day > startDate, day < endDate)

# calculate daily median, min and max of temperature
data <- data %>%
  group_by(day) %>%
  mutate(minDay = min(as.numeric(FlatA_Temp)),
         medianDay = median(as.numeric(FlatA_Temp)),
         maxDay = max(as.numeric(FlatA_Temp))
         ) %>%
  ungroup()

# shrink down to daily values and remove rows with empty values
data <- data %>% select(day, medianDay, minDay, maxDay) %>% unique() %>% na.omit()

# calculate medians for time ranges
data <- data %>%
  mutate(period = ifelse(day >= startDate & day <= optiDate1,
                         "Baseline",
                         ifelse((day >= (as.Date(optiDate1) + optiDelayDays))
                                & (day <= optiDate2),
                                "Opti1",
                                ifelse((day >= (as.Date(optiDate2) + optiDelayDays))
                                & (day <= endDate),
                                "Opti2",
                                NA)
                         )))

data <- data %>%
  group_by(period) %>%
  mutate(medianPeriod = ifelse(is.na(period), NA, median(medianDay))) %>% 
  ungroup() %>% 
  select(-period)

# create xts object for plotting
plotdata <- xts( x=data[,-1], order.by=data$day)

# plot graph
dygraph(plotdata, main = "Room Temperature Reduction") %>%
  dyAxis("x", drawGrid = FALSE) %>%
  dySeries(c("minDay", "medianDay", "maxDay"),
           label = "Temperature") %>%
  dySeries(c("medianPeriod"),
           label = "Median Period",
           strokePattern = "dashed") %>%
  dyOptions(colors = RColorBrewer::brewer.pal(3, "Set2")) %>%
  dyEvent(x = optiDate1,
          label = optiLabel1,
          labelLoc = "bottom",
          color = "slategray",
          strokePattern = "dotted") %>% 
  dyEvent(x = optiDate2,
          label = optiLabel2,
          labelLoc = "bottom",
          color = "slategray",
          strokePattern = "dotted") %>% 
  dyLimit(tempSetpoint,
          color = "red",
          label = "Setpoint") %>% 
  dyRangeSelector() %>% 
  dyLegend(show = "always")

```

### Discussion
In this example we used the dygraph package to create the graph. This package is fast and allows to show a rangeslider on the bottom of the graph. The exact same graph but without a slider is as well possible with ggplot.

Please note that the calculation of the periodic median after optimization I and II starts delayed because it takes time until the building has cooled down. 

## Building Energy Signature
### Task
You want to create a scatter plot with

* the daily mean outside temperature on the x-axis

* the daily energy consumption on the y-axis

* points colored according to season

### Basis

* Two separate csv files with time series data from the outside temperature and the energy data with unaligned time intervals 

* Energy consumption time series from a energy meter with steadily increasing meter values

### Solution
After reading in the two time series the data has to get aggregated per day and then merged. Note that during the aggregation of the energy data you have to calculate the daily conspumption from the steadiliy increasing meter values as well.

Create a new script, copy/paste the following code and run it:

```{r energysignature ggplot, warning=FALSE, message=FALSE, collapse = FALSE}
library(ggplot2)
library(plotly)
library(dplyr)
library(redutils)
library(lubridate)

# load time series data and aggregate daily mean values
dfOutsideTemp <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv",
                          stringsAsFactors=FALSE,
                          sep =";")

dfOutsideTemp$time <- parse_date_time(dfOutsideTemp$time,
                                      order = "YmdHMS",
                                      tz = "Europe/Zurich")

dfOutsideTemp$day <- as.Date(cut(dfOutsideTemp$time, breaks = "day"))

dfOutsideTemp <- dfOutsideTemp %>%
  group_by(day) %>%
  mutate(tempMean = mean(centralOutsideTemp)) %>%
  ungroup()

dfOutsideTemp <- dfOutsideTemp %>%
  select(day, tempMean) %>%
  unique() %>%
  na.omit()

dfHeatEnergy <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralHeating.csv",
                         stringsAsFactors=FALSE,
                         sep =";")

dfHeatEnergy <- dfHeatEnergy %>%
  select(time, energyHeatingMeter) %>%
  na.omit()

dfHeatEnergy$time <- parse_date_time(dfHeatEnergy$time,
                                     orders = "YmdHMS",
                                     tz = "Europe/Zurich")

dfHeatEnergy$day <- as.Date(cut(dfHeatEnergy$time, breaks = "day"))

dfHeatEnergy <- dfHeatEnergy %>%
  group_by(day) %>%
  mutate(energyMax = max(energyHeatingMeter)) %>%
  ungroup()

dfHeatEnergy <- dfHeatEnergy %>%
  select(day, energyMax) %>%
  unique() %>%
  na.omit()

dfHeatEnergy <- dfHeatEnergy %>% 
  mutate(energyCons = energyMax - lag(energyMax)) %>%
  select(-energyMax) %>%
  na.omit()

# merge the data in a tidy format
df <- merge(dfOutsideTemp, dfHeatEnergy, by = "day")

# calculate season
df <- df %>% mutate(season = redutils::season(df$day))

# static chart with ggplot
p <- ggplot2::ggplot(df) +
  ggplot2::geom_point(aes(x = tempMean,
                          y = energyCons, color=season,
                          text = paste("</br>Date:  ", as.Date(df$day),
                                       "</br>Temp: ", round(df$tempMean, digits = 1), "\u00B0C",
                                       "</br>Energy: ", round(df$energyCons, digits = 0), "kWh/d",
                                       "</br>Season: ", df$season))
                      ) +
  ggtitle("Building Energy Signature") +
        theme_minimal() +
        theme(
          legend.position="none",
          plot.title = element_text(hjust = 0.5)
        )
p
```

Add the following part to your script to make the chart above interactive:

```{r energysignature plotly, warning=FALSE, message=FALSE, collapse = FALSE}
# continuation from upper ggplot code section
plotly::ggplotly(p, tooltip = c("text")) %>%
  layout(xaxis = list(title = "Outside temperature (\u00B0C)",
                      range = c(min(-5,min(df$tempMean)), max(35,max(df$tempMean))), zeroline = F),
         yaxis = list(title = "Daily energy consumption (kWh/d)",
                      range = c(-5, max(df$energyCons) + 10)),
         showlegend = TRUE
         ) %>%
  plotly::config(displayModeBar = FALSE, displaylogo = FALSE)
```

## Mollier hx Diagram
### Task
You want to plot a mollier h-x diagram with

* scatter plot of temperature- and humidity sensor data (mean values per day)

* points colored according to season

* comfort zone

### Basis

* A csv file with time series from multiple temperature and humidity sensors in Â°C and %rH

### Solution
The sensor data is not in a constant intervall and not yet aggregated. So after reading in the time series the data has to get filtered and aggregated per day.

Finally use the plot function `mollierHxDiagram` from the `redutils` package (R Energy Data Utilities) which you can install as followed:

```{r eval=FALSE}
install.packages("devtools")
library(devtools)
install_github("hslu-ige-laes/redutils")
```
Create a new script, copy/paste the following code and run it:

```{r mollier hx, warning=FALSE, message=FALSE, collapse = FALSE}
library(redutils)
library(dplyr)
library(r2d3)
library(lubridate)

# read and print data
data <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv",
                 stringsAsFactors=FALSE,
                 sep =";")

# select temperature and humidity and remove empty cells
data <- data %>% select(time, FlatA_Temp, FlatA_Hum) %>% na.omit()

# create column with day for later grouping
data$time <- parse_date_time(data$time, "YmdHMS", tz = "Europe/Zurich")
data$day <- as.Date(cut(data$time, breaks = "day"))

# calculate daily mean of temperature and humidity
data <- data %>%
  group_by(day) %>%
  mutate(tempMean = mean(as.numeric(FlatA_Temp)),
         humMean = mean(as.numeric(FlatA_Hum))
         ) %>%
  ungroup()

# shrink down to daily values and remove rows with empty values
data <- data %>% select(day, tempMean, humMean) %>% unique() %>% na.omit()

# plot mollier hx diagram
redutils::mollierHxDiagram(data)
```

### Discussion
The diagram is based on D3 and packaged into the package `redutils`. The original D3 source with a html integration you can find here: <a href="https://github.com/hslu-ige-laes/d3-mollierhx" target="_blank">https://github.com/hslu-ige-laes/d3-mollierhx</a>

### See Also
If your two time series are in separate files, you must first read them in separately and then merge them into one data frame. See chapter \@ref(DATAWRANGLING-MERGE-TWO-DATAFRAMES)
