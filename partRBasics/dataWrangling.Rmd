# Data Wrangling
text tbd

## Add Metadata for later filtering
Firstly we have to load a dataset into a dataframe:
```{r metadata dataset, warning=FALSE, message=FALSE, collapse = FALSE}
# load data set
df <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv",
               stringsAsFactors=FALSE,
               sep =";")

```

### Year, Month, Day, Day of Week
To group, filter and aggregate data we need to have a the date splitted up in day, month and year separately:
```{r metadata date, eval = FALSE}
library(dplyr)
library(lubridate)

df$time <- parse_date_time(df$time, "YmdHMS", tz = "Europe/Zurich")
df$year <- as.Date(cut(df$time, breaks = "year"))
df$month <- as.Date(cut(df$time, breaks = "month"))
df$day <- as.Date(cut(df$time, breaks = "day"))
df$weekday <- wday(df$time,
                   label = TRUE,
                   locale = "English",
                   abbr = TRUE,
                   week_start = getOption("lubridate.week.start", 1))
```

This code first parses the timestamp with a specific timezone. Then three columns are added.

Please note that the month also contains the year and a day. This is useful for a later step where you can group the series afterwards. 

\newpage

```{r metadata date output, warning=FALSE, message=FALSE, collapse = FALSE}
head(df,2)
tail(df,2)
```

### Season of Year
For some analyses it is useful to color single points of a scatterplot according to the season. For this we need to have the season in a separate column: 

```{r metadata season1, warning=FALSE, message=FALSE, collapse = FALSE}
library(redutils)
# get season from a date
getSeason(as.Date("2019-04-01"))
```

If you want to change the language, you can give the function dedicated names for the season:

```{r metadata season2, warning=FALSE, message=FALSE, collapse = FALSE}
getSeason(as.Date("2019-04-01"),
                  seasonlab = c("Winter","FrÃ¼hling","Sommer","Herbst"))
```

To apply this function to a whole dataframe we can use the dplyr mutate function. The code below creates a new column named "season":

```{r metadata season3, warning=FALSE, message=FALSE, collapse = FALSE}
df <- dplyr::mutate(df, season = getSeason(df$time))
```

```{r metadata season3 output, warning=FALSE, message=FALSE, collapse = FALSE}
head(df,1)
tail(df,1)
```
## Data Frames
Firstly we have to load a dataset into a dataframe:
```{r metadata dataframe, warning=FALSE, message=FALSE, collapse = FALSE}
# load data set
df <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv",
               stringsAsFactors=FALSE,
               sep =";")
```
### Change Row Names
```{r change row names, warning=FALSE, message=FALSE, collapse = FALSE}
# Print the header and the first line
head(df, 1)

# rename columns and print the header and the first line
names(df) <- c("timestamp","Hum_A","Temp_A","Hum_B","Temp_B","Hum_C","Temp_C","Hum_D", "Temp_D")
head(df, 1)
```
### Wide to Long
```{r rbasics wide2long, warning=FALSE, message=FALSE, collapse = FALSE}

# create a copy of the dataframe and print the header and the first five line
head(df, 5)

# convert wide to long format
df.long <- as.data.frame(tidyr::pivot_longer(df,
                                             cols = -timestamp,
                                             names_to = "sensor",
                                             values_to = "value",
                                             values_drop_na = TRUE)
                         )

# long format
head(df.long, 16)
```
### Long to Wide
```{r rbasics long2wide, warning=FALSE, message=FALSE, collapse = FALSE}
# long format
head(df.long)

# convert long table into wide table
df.wide <- as.data.frame(tidyr::pivot_wider(df.long,
                                            names_from = "sensor",
                                            values_from = "value")
                         )

# wide format
head(df.wide)
```
### Merge two Dataframes {#DATAWRANGLING-MERGE-TWO-DATAFRAMES}
```{r dataframe merge, warning=FALSE, message=FALSE, collapse = FALSE}
library(dplyr)
library(lubridate)

# read file one and parse dates
dfOutsideTemp <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv",
                          stringsAsFactors=FALSE,
                          sep =";")

dfOutsideTemp$time <- parse_date_time(dfOutsideTemp$time,
                                      orders = "YmdHMS",
                                      tz = "Europe/Zurich")

# read file two and parse dates
dfFlatTempHum <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv",
                          stringsAsFactors=FALSE, sep =";")

dfFlatTempHum$time <- parse_date_time(dfFlatTempHum$time,
                                      order = "YmdHMS",
                                      tz = "Europe/Zurich")

# merge the two files into a new data frame and keep only rows where all values are available
df <- merge(dfOutsideTemp, dfFlatTempHum, by = "time") %>% na.omit()

```

## Examples
### Import csv file from GWF Relay W60 M-Bus Logger
Some data loggers have a cryptic data format which requires some data wrangling ahead before we can use the time series efficiently. Following an example of a M-Bus data loggger.

```{r w60 read csv, warning=FALSE, message=FALSE, collapse = FALSE}
library(tidyr)

# load csv file
df <- read.csv("https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater_GWF_RelayW60Logger.csv",
               stringsAsFactors=FALSE,
               sep =",")
head(df,23)
```

Please note
 * The Date and Time are in separate columns
 * The HCA-Unit value has a factor of 10, so the above HCA-value of 87 are in 10 liters Units and result in 87 * 10 = 870 liter
 * In the example "Adr" is the identification of the flat
 
We are only interested in Nr. 1 heating energy of the flat and Nr. 12 the impulse count of the additional meter which is the hot water of the flat.

Following the required steps to parse the data and bring them in a format we can later work with:

```{r w60 parsing, warning=FALSE, message=FALSE, collapse = FALSE}

# create timestamp out of column "Date" and "Time"
df <- df %>% mutate(timestamp = paste0(df$Datum, " ", df$Zeit))
df$timestamp <- parse_date_time(df$timestamp,
                                order = "d.m.y H:M",
                                tz = "Europe/Zurich")


# select columns and rearrange
df <- df %>% select(timestamp, Adr, Nr., Wert, Einheit)

# filter out Adr. of interest
df <- df %>% filter(Nr. %in% c(1,12))

# rename columns
df <- df %>% mutate(Nr. = ifelse(Nr. == 1, paste0("Adr",sprintf("%02.0f", Adr), "_energyHeat"), ifelse(Nr. == 12, paste0("Adr",sprintf("%02.0f", Adr), "_hotWater"), Nr.)))

# convert value to numeric
df$Wert <- as.numeric(df$Wert)

# multiply HCA-values by factor 10 to get liters and divide by 1000 to get m3
df <- df %>% mutate(Wert = ifelse((Einheit == "HCA"), Wert * 10/1000, Wert))

df <- df %>% select(-Einheit, -Adr)

# convert long table into wide table
df.wide <- as.data.frame(pivot_wider(df,
                                     names_from = "Nr.",
                                     values_from = Wert,
                                     names_sep = "_")
)
```

This is the result:
```{r w60 result, warning=FALSE, message=FALSE, collapse = FALSE}
head(df.wide)
```

Finally saving the csv file:
```{r w60 save csv, eval=FALSE}
write.csv2(df.wide,
           file = "flatHeatAndHotWater.csv",
           row.names = FALSE)
```
