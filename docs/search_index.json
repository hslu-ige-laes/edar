[["index.html", "Energy Data Analysis with R Chapter 1 Preface", " Energy Data Analysis with R Reto Marek 2021-04-17 Chapter 1 Preface This short book gives you an overview of the statistical software R and its ability to analyze and visualize time series in the context of building energy and comfort. The aim of this book is to provide additional specific recipes for energy and comfort related tasks and to make your entry into R smooth and easy. It is aimed at R beginners as well as exerienced R users and is inspired by the R Graphics Cookbook and Engineering Data Analysis in R. "],["content.html", "1.1 Content", " 1.1 Content The book is structured in the following main parts: R Basics Data Visualizations The part R Basics covers general data analysis tasks like data loading, wrangling and aggregation. Mostly this part deals with number juggling and table viewing. Numerical quantities focus on expected values, graphical summaries on unexpected values. - John W. Tukey Such so called graphical summaries are covered in the part Data Visualizations which brings the calculated numbers to life. Visualizations are good to identify patterns, changes over time, unusual readings, and relationships between variables. The presented code makes the creation of common and useful plots for energy and comfort data fast and easy. The recipes in this part will show you how to complete certain specific tasks. Examples are shown so that you can understand the basic principle and reproduce the analysis or visualization with your own data. Simply copy the code into your R-script, run it and if you like the visualization replace the sample data with your own. "],["why-r-and-rstudio.html", "1.2 Why R and RStudio?", " 1.2 Why R and RStudio? In the EVISUstudy of the Lucerne University of Applied Sciences and Arts, experts from the field were asked how and where they perform energy analyses and create visualizations. The result was that many people today either need Excel or use a building monitoring software to execute analysis and as well for making visualizations. Excel users are pushing the program to its limits with the ever-increasing data sets. Also the interactive ability of the graphics there is limited. Switching to an analysis environment like R seems unavoidable for more complex tasks, but apparently causes problems for many people. In the market there are numerous books which make the start in R easier. There are also packages for various fields which support the discipline-specific analysis and visualization tasks. However, experts from the energy and building services engineering industry lack a corresponding work and corresponding packages. The present book is intended to close the first gap, the second gets closed by the package redutils - Energy Data Utilities for R. You might also wonder why R and not Python. Well, this is a question of faith and the author seems to prefer R. "],["further-reading.html", "1.3 Further Reading", " 1.3 Further Reading A really good source is R for Data Science by Garrett Grolemund and Hadley Wickham. The entire book is freely available online through the same format of this book. There are a number of other recommendable and free online books available, including: R Graphics Cookbook by Winston Chang Introduction to Data Science - Data Analysis and Prediction Algorithms with R by Rafael A. Irizarry Hands-On Programming with R by Garrett Grolemund Engineering Data Analysis in R by John Volckens and Kathleen E. Wendt Forecasting: Principles and Practice by Rob J Hyndman and George Athanasopoulos "],["acknowledgements.html", "1.4 Acknowledgements", " 1.4 Acknowledgements The author would like to express his sincere thank to the Swiss Federal Office of Energy, as the launch of this book was part of a project of the research program Buildings and Cities 2018. This book was developed using Yihui Xies bookdown framework. The book is built using code that combines R code, data, and text to create a book for which R code and examples can be re-executed every time the book is re-built. The online book is hosted using GitHubs free GitHub Pages. All material for this book is available and can be explored at the books GitHub repository. "],["getting-started.html", "Chapter 2 Getting started", " Chapter 2 Getting started Before we can start with the analysis described in the later chapters, we have to install R. Therefore the first two parts of this chapter get you up and running with downloading and installing the relevant software and packages. This may seem laborious, but it is necessary and easier than it appears at first glance. If you already have R and R Studio installed, please take a look at the redutils package on github, which is frequently used throughout this book. Chapter 2.2 shows you how to install it. "],["installation.html", "2.1 Install R and R Studio", " 2.1 Install R and R Studio R is a programming language used for statistical computing while RStudio provides a graphical user interface R may be used without RStudio, but RStudio may not be used without R Both, R and RStudio are free of charge and there are no licencse fees When you later make an analysis and visualizations, you only work in the graphical user interface RStudio 2.1.1 Download and Install R Windows Open https://cran.r-project.org/bin/windows/base/ and press the link Download R Run the downloaded installer file and follow the installation wizard The wizard will install R into your Program Files folders and adds a shortcut in your Start menu. Note that you will need to have all necessary administration rights to install new software on your machine. Mac OSX 1. Open https://cran.r-project.org/bin/macosx/ and download the latest *.pkg file 1. Run the downloaded installer file and follow the installation wizard The installer allows you to customize your installation. However the default values will be suitable for most users. Linux R is part of many Linux distributions, therefore you should check with your Linux package management system if its already installed. The CRAN website provides files to build R from source on Debian, Redhat, SUSE, and Ubuntu systems under the link Download R for Linux Open https://cran.r-project.org/bin/linux/ and then follow the directory trail to the version of Linux you wish to install R on top of The exact installation procedure will vary depending on your Linux operating system. CRAN supports the process by grouping each set of source files with documentation or README files that explain how to install on your system. 2.1.2 Download and Install RStudio Open https://rstudio.com/products/rstudio/download/ and download RStudio Desktop Open Source Follow the on-screen instructions Once you have installed R Studio, you can run it like any other application by clicking the program icon "],["installationPackages.html", "2.2 Install required packages", " 2.2 Install required packages Appendix A gives you an introduction to what a package is and how to install it. Fo.low these instructions to install the packages used in this book: Open RStudio just as you would any program, by clicking on its icon Copy the following code and paste it into your console (on the bottom left, right of the symbol &gt;): install.packages(&quot;devtools&quot;, &quot;tidyverse&quot;, &quot;plotly&quot;, &quot;lubridate&quot;, &quot;r2d3&quot;) install_github(&quot;hslu-ige-laes/redutils&quot;) Press Enter or Return The installation of the packages is now in progress and this may take a while, please be patient. In the meantime you can read in appendix A what packages are in general and how they can be installed and later loaded into scripts. "],["createFirstScript.html", "2.3 Create your first R Script", " 2.3 Create your first R Script Finally, you have installed R and RStudio with some packages on your computer. Good, hopefully everything worked fine up to now. Lets create the first script with a visualization: Open RStudio just as you would any program, by clicking on its icon Go to the menu on the top left and click to File / New File / R Script Copy the following code and paste it into your script: library(graphics) plot(co2, ylab = &quot;CO2 (ppm)&quot;, las = 1) title(main = &quot;Mauna Loa Atmospheric CO2 Concentration&quot;) select all by pressing Ctrl + A Thren run the code by pressing the Run Button or Ctrl + Enter You should now get your first visualization: As you probably noticed, we did not load any data. The basic installation of R and some packages come with test data. So that is an easy way to test something. The R Dataset Package provides some preinstalled datasets, including the used Mauna Loa Atmospheric CO2 Concentration dataset. "],["introduction-to-r-basics.html", "Chapter 3 Introduction to R Basics", " Chapter 3 Introduction to R Basics The following chapters of the part R-Basics give an overview of the basic principles for understanding the recipes in the part Data Visualizations. It focuses on practical examples of how data can be loaded, transformed and analyzed. It is not the goal of this book to introduce beginners completely to the programming language R and the environment in general. There are many really good sources where you can familiarize yourself with R if necessary. Two are recommended to facilitate the introduction to R and to learn the relevant basics. Choose one that suits you and go through the recommended chapter: Introduction to Data Science - Chapter 2 R Basics Engineering Data Analysis in R - Chapter 2 The R Programming Environment Throughout the book, reference is made to these two continuative sources and you only need to read the one that appeals to you more. In the referenced chapters, these cover similar content. "],["loading-data.html", "Chapter 4 Loading Data", " Chapter 4 Loading Data This chapter introduces two functions that can be used to load data from csv- and Excel-files. Experienced readers will find more information about data imports here: Introduction to Data Science - Chapter 5 Importing data Engineering Data Analysis in R - Chapter 3 Getting and Cleaning Data csv-Files Load data from comma separated files # read data from current folder df &lt;- read.csv(&quot;datafile.csv&quot;) # read data from a specific folder df &lt;- read.csv(&quot;C:/Desktop/datafile.csv&quot;) # read data from a file in the internet df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatElectricity.csv&quot;) # add arguments on how to parse the content df &lt;- read.csv(&quot;datafile.csv&quot;, header=FALSE, stringsAsFactors=FALSE, sep =&quot;,&quot;, na.strings = c(&quot;&quot;, &quot;NA&quot;)) Attention: By default, strings in the data are treated as factors, so add stringsAsFactors=FALSE Set your cursor to the function name read.csv() and press F1. Then you get in R Studio bottom right in the tab Help information about other function arguments you can use. Note that the function read.csv() has the default sep =\",\" and read.csv2() has the default sep =\";\" Excel-Files Load data from *.xlsx Excel files: # Only need to install once install.packages(&quot;xlsx&quot;) library(xslx) df &lt;- read.xlsx(&quot;datafile.xlsx&quot;, 1) df &lt;- read.xlsx(&quot;datafile.xlsx&quot;, sheetIndex=2) df &lt;- read.xlsx(&quot;datafile.xlsx&quot;, sheetName=&quot;Revenues&quot;) # show the first lines of the so called &quot;data frame&quot; head(df) For reading older Excel files in the .xls format, the gdata package has the function read.xls: # Only need to install once install.packages(&quot;gdata&quot;) library(gdata) df &lt;- read.xls(&quot;datafile.xls&quot;) # Read first sheet df &lt;- read.xls(&quot;datafile.xls&quot;, sheet=2) # Read second sheet Both the xlsx and gdata packages require other software to be installed on your computer. For xlsx, you need to install Java on your machine. For gdata, you need Perl, which comes as standard on Linux and Mac OS X, but not Windows. On Windows, youll need ActiveState Perl. The Community Edition can be obtained for free. "],["data-wrangling.html", "Chapter 5 Data Wrangling", " Chapter 5 Data Wrangling This chapter gives an overview of the most important data manipulation functions used throughout this book. Experienced readers will find more information about data imports here Introduction to Data Science - Chapter 4 The tidyverse Engineering Data Analysis in R - Chapter 3.5 Data Cleaning Engineering Data Analysis in R - Chapter 3.6 Piping It is a fact that the data import and manipulation part of analyses often takes more time than the actual analysis or visualization itself. This is because the exchange data formats are not standardized and meters and sensors record at different time intervals. Data quality, missing data, data imputation and data cleansing also play a major role. "],["add-metadata-for-later-filtering.html", "5.1 Add Metadata for later filtering", " 5.1 Add Metadata for later filtering Firstly we have to load a dataset into a dataframe: # load data set df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) 5.1.1 Year, Month, Day, Day of Week To e.g. group, filter and aggregate data we need eventually the date splitted up in day, month and year: library(dplyr) library(lubridate) df$time &lt;- parse_date_time(df$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$year &lt;- as.Date(cut(df$time, breaks = &quot;year&quot;)) df$month &lt;- as.Date(cut(df$time, breaks = &quot;month&quot;)) df$day &lt;- as.Date(cut(df$time, breaks = &quot;day&quot;)) df$weekday &lt;- wday(df$time, label = TRUE, locale = &quot;English&quot;, abbr = TRUE, week_start = getOption(&quot;lubridate.week.start&quot;, 1)) This code first parses the timestamp with a specific timezone. Then three columns are added. Please note that the month also contains the year and a day. This is useful for a later step where you can group the series afterwards. head(df,2) ## time centralOutsideTemp ## 1 2018-03-21 11:00:00 5.2 ## 2 2018-03-21 12:00:00 6.7 tail(df,2) ## time centralOutsideTemp ## 21864 2020-09-17 10:00:00 26.65 ## 21865 2020-09-17 11:00:00 28.10 5.1.2 Hour, Minute, Second df$hour &lt;- as.POSIXct(lubridate::floor_date(df$time,&quot;hours&quot;), tz = &quot;Europe/Zurich&quot;) df$minute &lt;- as.POSIXct(lubridate::floor_date(df$time,&quot;minutes&quot;), tz = &quot;Europe/Zurich&quot;) df$second &lt;- as.POSIXct(lubridate::floor_date(df$time,&quot;seconds&quot;), tz = &quot;Europe/Zurich&quot;) 5.1.3 Season of Year For some analyses it is useful to color single points of a scatterplot according to the season. For this we need to have the season in a separate column: library(redutils) # get season from a date getSeason(as.Date(&quot;2019-04-01&quot;)) ## [1] &quot;Spring&quot; If you want to change the language, you can give the function dedicated names for the season: getSeason(as.Date(&quot;2019-04-01&quot;), seasonlab = c(&quot;Winter&quot;,&quot;Frühling&quot;,&quot;Sommer&quot;,&quot;Herbst&quot;)) ## [1] &quot;Frühling&quot; To apply this function to a whole dataframe we can use the dplyr mutate function. The code below creates a new column named season: df &lt;- dplyr::mutate(df, season = getSeason(df$time)) head(df,1) ## time centralOutsideTemp season ## 1 2018-03-21 11:00:00 5.2 Spring tail(df,1) ## time centralOutsideTemp season ## 21865 2020-09-17 11:00:00 28.1 Fall "],["manipulating-data-frames.html", "5.2 Manipulating Data Frames", " 5.2 Manipulating Data Frames The dplyr package from the tidyverse introduces functions that perform some of the most common operations when working with data frames and uses names for these functions that are relatively easy to remember. 5.2.1 Change Row Names # rename columns names(df) &lt;- c(&quot;timestamp&quot;,&quot;humidity&quot;,&quot;temp_c&quot;) 5.2.2 Adding a column with mutate() library(dplyr) # add new column with temperature conversion from celsius to fahrenheit df &lt;- dplyr::mutate(df, temp_f = temp_c * 1.8 + 32) # This code does the same, but only with a pipe df &lt;- df %&gt;% dplyr::mutate(df, temp_f = temp_c * 1.8 + 32) 5.2.3 Subsetting with filter() library(dplyr) # add new column with temperature conversion from celsius to fahrenheit df &lt;- filter(df, timestamp &gt;= &quot;2020-01-01 00:00:00&quot;, timestamp &lt;= &quot;2020-12-31 23:45:00&quot;) df.high &lt;- filter(df, temp_c &gt; 30) Note: Whether you put the whole code on one line or split it after a comma does not have an effect on the computation, it is only more readable when the lines arent too wide. 5.2.4 Add/remove columns with select() library(dplyr) # Based on the upper example we remove the celsius column after calculation df &lt;- select(df, -temp_c) # Create new data frame df.new &lt;- select(df, timestamp, temp_f) # use select() in a so called dplyr pipe df &lt;- df %&gt;% dplyr::mutate(df, temp_f = temp_c * 1.8 + 32) %&gt;% select(-temp_c) 5.2.5 The pipe %&gt;% With the package dplyr we can perform a series of operations, for example select and then filter, by sending the results of one function to another using what is called the pipe operator: %&gt;%. Details can be found in Introduction to Data Science - Chapter 4.5 5.2.6 Wide to Long library(tidyr) # load test data set df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # create a copy of the dataframe and print the header and the first five line head(df, 5) ## time FlatA_Hum FlatA_Temp FlatB_Hum FlatB_Temp FlatC_Hum ## 1 2018-10-03 00:00:00 53.0 24.43 38.8 22.40 44.0 ## 2 2018-10-03 01:00:00 53.0 24.40 38.8 22.40 44.0 ## 3 2018-10-03 02:00:00 53.0 24.40 39.3 22.40 44.7 ## 4 2018-10-03 03:00:00 53.0 24.40 40.3 22.40 45.0 ## 5 2018-10-03 04:00:00 53.3 24.40 41.0 22.37 45.2 ## FlatC_Temp FlatD_Hum FlatD_Temp ## 1 24.5 49.0 24.43 ## 2 24.5 49.0 24.40 ## 3 24.5 48.3 24.38 ## 4 24.5 48.0 24.33 ## 5 24.5 47.7 24.30 # convert wide to long format df.long &lt;- as.data.frame(tidyr::pivot_longer(df, cols = -time, names_to = &quot;sensor&quot;, values_to = &quot;value&quot;, values_drop_na = TRUE)) # long format head(df.long, 16) ## time sensor value ## 1 2018-10-03 00:00:00 FlatA_Hum 53.00 ## 2 2018-10-03 00:00:00 FlatA_Temp 24.43 ## 3 2018-10-03 00:00:00 FlatB_Hum 38.80 ## 4 2018-10-03 00:00:00 FlatB_Temp 22.40 ## 5 2018-10-03 00:00:00 FlatC_Hum 44.00 ## 6 2018-10-03 00:00:00 FlatC_Temp 24.50 ## 7 2018-10-03 00:00:00 FlatD_Hum 49.00 ## 8 2018-10-03 00:00:00 FlatD_Temp 24.43 ## 9 2018-10-03 01:00:00 FlatA_Hum 53.00 ## 10 2018-10-03 01:00:00 FlatA_Temp 24.40 ## 11 2018-10-03 01:00:00 FlatB_Hum 38.80 ## 12 2018-10-03 01:00:00 FlatB_Temp 22.40 ## 13 2018-10-03 01:00:00 FlatC_Hum 44.00 ## 14 2018-10-03 01:00:00 FlatC_Temp 24.50 ## 15 2018-10-03 01:00:00 FlatD_Hum 49.00 ## 16 2018-10-03 01:00:00 FlatD_Temp 24.40 5.2.7 Long to Wide # long format head(df.long) ## time sensor value ## 1 2018-10-03 00:00:00 FlatA_Hum 53.00 ## 2 2018-10-03 00:00:00 FlatA_Temp 24.43 ## 3 2018-10-03 00:00:00 FlatB_Hum 38.80 ## 4 2018-10-03 00:00:00 FlatB_Temp 22.40 ## 5 2018-10-03 00:00:00 FlatC_Hum 44.00 ## 6 2018-10-03 00:00:00 FlatC_Temp 24.50 # convert long table into wide table df.wide &lt;- as.data.frame(tidyr::pivot_wider(df.long, names_from = &quot;sensor&quot;, values_from = &quot;value&quot;) ) # wide format head(df.wide) ## time FlatA_Hum FlatA_Temp FlatB_Hum FlatB_Temp FlatC_Hum ## 1 2018-10-03 00:00:00 53.0 24.43 38.8 22.40 44.0 ## 2 2018-10-03 01:00:00 53.0 24.40 38.8 22.40 44.0 ## 3 2018-10-03 02:00:00 53.0 24.40 39.3 22.40 44.7 ## 4 2018-10-03 03:00:00 53.0 24.40 40.3 22.40 45.0 ## 5 2018-10-03 04:00:00 53.3 24.40 41.0 22.37 45.2 ## 6 2018-10-03 05:00:00 53.7 24.40 41.2 22.30 47.2 ## FlatC_Temp FlatD_Hum FlatD_Temp ## 1 24.50 49.0 24.43 ## 2 24.50 49.0 24.40 ## 3 24.50 48.3 24.38 ## 4 24.50 48.0 24.33 ## 5 24.50 47.7 24.30 ## 6 24.57 47.2 24.30 5.2.8 Merge two Dataframes library(dplyr) library(lubridate) # read file one and parse dates dfOutsideTemp &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfOutsideTemp$time &lt;- parse_date_time(dfOutsideTemp$time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # read file two and parse dates dfFlatTempHum &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfFlatTempHum$time &lt;- parse_date_time(dfFlatTempHum$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # merge the two files into a new data frame and keep only rows where all values are available df &lt;- merge(dfOutsideTemp, dfFlatTempHum, by = &quot;time&quot;) %&gt;% na.omit() head(df) ## time centralOutsideTemp FlatA_Hum FlatA_Temp FlatB_Hum ## 1 2018-10-03 00:00:00 11.80 53.0 24.43 38.8 ## 2 2018-10-03 01:00:00 11.25 53.0 24.40 38.8 ## 3 2018-10-03 02:00:00 11.45 53.0 24.40 39.3 ## 4 2018-10-03 03:00:00 11.40 53.0 24.40 40.3 ## 5 2018-10-03 04:00:00 11.10 53.3 24.40 41.0 ## 6 2018-10-03 05:00:00 11.05 53.7 24.40 41.2 ## FlatB_Temp FlatC_Hum FlatC_Temp FlatD_Hum FlatD_Temp ## 1 22.40 44.0 24.50 49.0 24.43 ## 2 22.40 44.0 24.50 49.0 24.40 ## 3 22.40 44.7 24.50 48.3 24.38 ## 4 22.40 45.0 24.50 48.0 24.33 ## 5 22.37 45.2 24.50 47.7 24.30 ## 6 22.30 47.2 24.57 47.2 24.30 "],["explorative-data-analysis.html", "Chapter 6 Explorative Data Analysis", " Chapter 6 Explorative Data Analysis Explorative Data Analysis (EDA) is a technique based on the human characteristic of visual pattern recognition. The purpose of EDA is simple: learn more about data by visualizing it in different ways. Exploratory data analysis is graphical detective work. - John W. Tukey, considered the founder of EDA "],["get-overview-of-data.html", "6.1 Get Overview of Data", " 6.1 Get Overview of Data A first step is getting an overview of the whole data set and specific series of it. 6.1.1 Load data Load test data set in a data frame (e.g. from a csv-file): ## Warning: 3 failed to parse. 6.1.2 Names Show the column headers of a data frame: names(df) ## [1] &quot;time&quot; &quot;energyHeatingMeter&quot; &quot;supplyTempHeating&quot; 6.1.3 Structure Show the structure of the data frame: str(df) ## &#39;data.frame&#39;: 22317 obs. of 3 variables: ## $ time : POSIXct, format: &quot;2018-03-03 00:00:00&quot; &quot;2018-03-03 01:00:00&quot; ... ## $ energyHeatingMeter: num 45020 NA NA NA NA ... ## $ supplyTempHeating : num 24.7 24.1 23.7 23.4 31.6 ... 6.1.4 Head/Tail Show the first and last values: head(df) ## time energyHeatingMeter supplyTempHeating ## 1 2018-03-03 00:00:00 45019.81 24.73 ## 2 2018-03-03 01:00:00 NA 24.06 ## 3 2018-03-03 02:00:00 NA 23.73 ## 4 2018-03-03 03:00:00 NA 23.45 ## 5 2018-03-03 04:00:00 NA 31.59 ## 6 2018-03-03 05:00:00 NA 29.14 tail(df) ## time energyHeatingMeter supplyTempHeating ## 22312 2020-09-17 15:00:00 NA NA ## 22313 2020-09-17 16:00:00 NA NA ## 22314 2020-09-17 17:00:00 NA NA ## 22315 2020-09-17 18:00:00 NA NA ## 22316 2020-09-17 19:00:00 NA NA ## 22317 2020-09-17 20:00:00 NA NA Note: if you want to show only the first three entries, you can type head(df,3) 6.1.5 Five number summary Reveals details about the distribution of the data: summary(df$supplyTempHeating) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 18.37 23.35 24.61 25.72 27.49 44.68 362 "],["quick-data-visualizations.html", "6.2 Quick Data Visualizations", " 6.2 Quick Data Visualizations Please refer to the R Graphics Cookbook from Winston Chang - Chapter 2 Quickly Exploring Data. This is a great resource where you can find everything you need to know about creating basic plots. Some plots of the part Data Visualizations are as well easy to create and can get used in the context of EDA. "],["introduction-to-data-visualizations.html", "Chapter 7 Introduction to Data Visualizations", " Chapter 7 Introduction to Data Visualizations In the following chapters of the Data Visualizations section, visualizations are presented that are either already frequently used in the field of building monitoring, are difficult to create or seem to be recommendable. Sometimes not the final creation of the lines is challenging, but the preceding data preparation of the raw data. Therefore all parts of the data preparation from the raw-files up to the final visualization are shown as recipes. The focus is on visualizations for reports in print quality. However, since some functions are implemented in the redutils package and are thus easy to call up, they are therefore also suitable for the fast visualization of data in the field of explorative data analysis. "],["statistical-characteristics.html", "Chapter 8 Statistical Characteristics", " Chapter 8 Statistical Characteristics The first step of a data analysis is to become familiar with the data. For this purpose some visualizations of statistical parameters are presented hereafter. "],["boxplot.html", "8.1 Boxplot", " 8.1 Boxplot 8.1.1 Goal You want to create a boxplot: Figure 8.1: Building Energy Signature Plot 8.1.2 Data Basis A csv file with room temperature and humidity time series of four rooms. Below are only the room temperatures visualized. Figure 8.2: Room Temperature Raw Data for Boxplot 8.1.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) library(tidyr) library(redutils) library(lubridate) # load time series data and aggregate daily mean values df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) df$time &lt;- parse_date_time(df$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df &lt;- df %&gt;% select(time, FlatA_Temp, FlatB_Temp, FlatC_Temp, FlatD_Temp) df &lt;- as.data.frame(tidyr::pivot_longer(df, cols = -time, names_to = &quot;room&quot;, values_to = &quot;Temp&quot;, values_drop_na = TRUE)) minY &lt;- round(min(df %&gt;% select(Temp), na.rm = TRUE) - 1, digits = 0) maxY &lt;- round(max(df %&gt;% select(Temp), na.rm = TRUE) + 1, digits = 0) plot &lt;- ggplot(df, aes(x = room, y = Temp)) + geom_boxplot(outlier.alpha = 0.01, outlier.shape = 1, outlier.colour = &quot;darkgrey&quot;) + scale_y_continuous(limits=c(minY,maxY), breaks = seq(minY, maxY, by = 2)) + ggtitle(&quot;Boxplot per Flat/Room&quot;) + theme_minimal() + theme( legend.position=&quot;none&quot;, plot.title = element_text(hjust = 0.5) ) yaxis &lt;- list( title = &quot;Temp&lt;sub&gt;Room&lt;/sub&gt; in \\u00B0C\\n&quot;, automargin = TRUE, titlefont = list(size = 14, color = &quot;darkgrey&quot;) ) # create interactive plot ggplotly(plot + ylab(&quot; &quot;) + xlab(&quot; &quot;)) %&gt;% plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE, toImageButtonOptions = list( format = &quot;svg&quot; ) ) %&gt;% layout(yaxis = yaxis) # save static plot as png (optional) ggsave(&quot;images/boxplot.png&quot;, plot) "],["cross-correlation.html", "8.2 Cross-Correlation", " 8.2 Cross-Correlation 8.2.1 Goal You want to create a cross-correlation plot: Figure 8.3: Building Energy Signature Plot 8.2.2 Data Basis Figure 8.4: Raw Data Room and Outdoor Temperature for Cross Correlation Plot Figure 8.5: Raw Data Room and Outdoor Temperature for Cross Correlation Plot 8.2.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(zoo) library(plotly) library(forecast) # load time series data and aggregate mean values dfTempOa &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfTempOa$time &lt;- parse_date_time(dfTempOa$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) dfTempOa$day &lt;- as.Date(cut(dfTempOa$time, breaks = &quot;days&quot;)) dfTempOa &lt;- dfTempOa %&gt;% group_by(day) %&gt;% dplyr::summarize(tempOa = mean(centralOutsideTemp, na.rm = TRUE)) %&gt;% ungroup() dfTempR &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfTempR$time &lt;- parse_date_time(dfTempR$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) # select temperature and humidity and remove empty cells dfTempR &lt;- dfTempR %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() dfTempR$day &lt;- as.Date(cut(dfTempR$time, breaks = &quot;days&quot;)) dfTempR &lt;- dfTempR %&gt;% group_by(day) %&gt;% dplyr::summarize(tempR = mean(FlatA_Temp, na.rm = TRUE)) %&gt;% ungroup() data &lt;- merge(dfTempR, dfTempOa, all = TRUE) %&gt;% unique() %&gt;% na.omit() data$season &lt;- redutils::getSeason(data$day) data &lt;- data %&gt;% filter(season == &quot;Summer&quot;) # plot diagram plot &lt;- ggCcf(data$tempOa, data$tempR, lag.max = 7) + theme_minimal() + scale_x_continuous(limits = c(-7, 0), breaks = seq(-7,0,1)) + scale_y_continuous(limits = c(-1, 1), breaks = seq(-1,1,0.2)) + labs(title=&quot;Cross Correlation between \\n Indoor and Outdoor Temperature in Summer&quot;, x =&quot;Days (Lag)&quot;, y = &quot;Correlation&quot;) # make plot interactive (optional) ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/crossCorrelation.png&quot;, plot) "],["density-plot.html", "8.3 Density Plot", " 8.3 Density Plot 8.3.1 Goal You want to create a density plot of a temperature series with the mean value as vertical line: Figure 8.6: Density Plot Temperature 8.3.2 Data Basis Figure 8.7: Raw Data Temperature for Density Plot 8.3.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) # load time series data and aggregate daily mean values library(dplyr) library(lubridate) # read and print data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and remove empty cells df &lt;- df %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() colnames(df) &lt;- c(&quot;time&quot;, &quot;value&quot;) # static chart with ggplot plot &lt;- ggplot(df, aes(x = value)) + geom_density() + geom_vline(aes(xintercept = mean(value, na.rm = TRUE)), color = &quot;orange&quot;, linetype = &quot;dashed&quot;, size = 1, label = &quot;Mean&quot;)+ ggtitle(&quot;Density Plot of Room Temperature&quot;) + labs(x = &quot;Temperature (\\u00B0C)&quot;, y = &quot;Density (-)&quot;) + theme_minimal() # interactive chart plotly::ggplotly(plot) # save static plot as png ggsave(&quot;images/plotDensity.png&quot;, plot) "],["density-plot-season.html", "8.4 Density Plot Season", " 8.4 Density Plot Season 8.4.1 Goal You want to create a density plot of a temperature series for each season of the year: Figure 8.8: Density Plot Temperature for each season of the year 8.4.2 Data Basis Figure 8.9: Raw Data Temperature for Density Plot 8.4.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) # load time series data and aggregate daily mean values library(dplyr) library(lubridate) library(redutils) # read and print data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and remove empty cells df &lt;- df %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() colnames(df) &lt;- c(&quot;time&quot;, &quot;value&quot;) df$season = getSeason(df$time) # static chart with ggplot plot &lt;- ggplot(df) + geom_density(aes(x = value, colour = season)) + scale_color_manual(values=c(&quot;#440154&quot;, &quot;#2db27d&quot;, &quot;#fde725&quot;, &quot;#365c8d&quot;)) + ggtitle(&quot;Density Plot of Room Temperature for each season of the year&quot;) + labs(x = &quot;Temperature (\\u00B0C)&quot;, y = &quot;Density (-)&quot;, colour = &quot;Legend&quot;) + theme_minimal() # interactive chart plotly::ggplotly(plot) # save static plot as png ggsave(&quot;images/plotDensitySeasons.png&quot;, plot) "],["time-series-decomposition.html", "Chapter 9 Time Series Decomposition", " Chapter 9 Time Series Decomposition Typical time series result from the interaction of regular deterministic and random causes. The deterministic regular causes can vary periodically (seasonally) and/or contain long-term trends. Random causes are often also called noise. Decomposition breaks down time series into their components trend, seasonality and randomness. For further data analysis it is often necessary to decompose the trend and the seasonal component from the raw data. Therefore, a large part of the time series analyses deals with corresponding procedures. Sometimes the remaining Randomness is of interest and sometimes a detrended series as in chapter 12.4. Trend Component The trend component of a time series refers to the general direction in which the time series moves in the long term. Time series can have a positive or negative trend, or no trend, but they can also have no trend. A trend is present when the data show a continuously rising and/or falling direction. Seasonal Component The seasonal component for time series data refers to their tendency to rise and fall with constant frequency. Seasonality occurs over a fixed and known period of time (e.g. the quarter of the year, the month or the day of the week). Random/Remainder/Irregular Component The rest is what remains of the time series data after its trend and seasonal components have been removed. It is the random fluctuation in the time series data that cannot be explained by the above components. For energy data analysis, each of the three components mentioned above may be of interest, depending on the case. This chapter shows how a time series can be decomposed and presented interactively. An exemplary decomposition of an outside temperature time series over 7 days: Figure 9.1: Time Series Decomposition Outside Temperature over 7 days "],["long-term.html", "9.1 Long term", " 9.1 Long term 9.1.1 Goal Decompose a long term time series of ten years monthly data: Figure 9.2: Decomposition of long time series over 10 Years 9.1.2 Data Basis Figure 9.3: Raw Data for Decomposition Plot Long Term 9.1.3 Solution Create a new script, copy/paste the following code and run it: library(dplyr) library(lubridate) library(plotly) library(ggplot2) library(forecast) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;Time&quot;, &quot;meterValue&quot;) df$Time &lt;- parse_date_time(df$Time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% dplyr::mutate(value = lead(meterValue) - meterValue) # remove counter value column df &lt;- df %&gt;% select(-meterValue) %&gt;% na.omit() df[1,2] &lt;- 600 df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 12, start = min(year(df$Time))) df.decompose &lt;- df.ts[,1] %&gt;% stl(s.window = 7) df.decompose &lt;- df.decompose$time.series df.decompose &lt;- as.data.frame(df.decompose) df.decompose &lt;- cbind(df, df.decompose) data &lt;- as.data.frame(tidyr::pivot_longer(df.decompose, cols = -Time, names_to = &quot;Component&quot;, values_to = &quot;Value&quot;, values_drop_na = TRUE) ) data$component &lt;- as.factor(data$Component) data$component &lt;- factor(data$Component, c(&quot;value&quot;, &quot;trend&quot;, &quot;seasonal&quot;, &quot;remainder&quot;)) data$Value &lt;- round(data$Value, digits = 1) plot &lt;- ggplot(data) + geom_path(aes(x = Time, y = Value ), color = &quot;black&quot;, alpha = 0.7) + facet_wrap(~component, ncol = 1, scales = &quot;free_y&quot;) + scale_x_datetime(date_breaks = &quot;years&quot; , date_labels = &quot;%Y&quot;) + theme_minimal() + theme(panel.spacing = unit(1, &quot;lines&quot;), legend.position = &quot;none&quot;) + labs(x = &quot;&quot;) + ggtitle(&quot;Time Series Decomposition over 10 Years&quot;) ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/plotDecompositionLong.png&quot;, plot) 9.1.4 Discussion Energy optimization in mid-2017 is clearly visible in the trend and also in the magnitude of the seasonal pattern And as well in the remainder the too low setting of January 2018 where the thermostat of the flat got deactivated The trend shows as well an higher consumption in June 2013 "],["short-term.html", "9.2 Short term", " 9.2 Short term 9.2.1 Goal Decompose a short term time series of e.g. 5 days 15min data: Figure 9.4: Seasonal Plot Overlapping per Month over 10 Years 9.2.2 Data Basis Figure 9.5: Raw Data for Decomposition Plot Short Term 9.2.3 Solution Create a new script, copy/paste the following code and run it: library(dplyr) library(lubridate) library(plotly) library(ggplot2) library(forecast) # change language to English, otherwise weekdays are in local language Sys.setlocale(&quot;LC_TIME&quot;, &quot;English&quot;) ## [1] &quot;English_United States.1252&quot; # load time series data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/eboBookEleMeter.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # rename column names colnames(df) &lt;- c(&quot;time&quot;, &quot;meterValue&quot;) df$time &lt;- parse_date_time(df$time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$time &lt;- force_tz(df$time, tzone = &quot;UTC&quot;) # uncomment to filter time range if necessary #df &lt;- df %&gt;% filter(Time &gt; &quot;2015-03-01 00:00:00&quot;, Time &lt; &quot;2015-04-01 00:00:00&quot;) # Fill missing values with NA grid.df &lt;- data.frame(time = seq(min(df$time, na.rm = TRUE), max(df$time, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% dplyr::mutate(value = (meterValue - lag(meterValue))*4) %&gt;% select(-meterValue) %&gt;% na.omit() # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) # select time range df &lt;- df %&gt;% filter(time &gt;= as.POSIXct(&quot;2015-01-26 00:00:00&quot;, tz = &quot;UTC&quot;), time &lt; as.POSIXct(&quot;2015-01-31 00:00:00&quot;, tz = &quot;UTC&quot;)) # =========== Start of Code ================ df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 96) df.decompose &lt;- df.ts[,1] %&gt;% stl(s.window = 193) df.decompose &lt;- df.decompose$time.series df.decompose &lt;- as.data.frame(df.decompose) df.decompose &lt;- cbind(df, df.decompose) data &lt;- as.data.frame(tidyr::pivot_longer(df.decompose, cols = -time, names_to = &quot;component&quot;, values_to = &quot;value&quot;, values_drop_na = TRUE) ) data$component &lt;- as.factor(data$component) data$component &lt;- factor(data$component, c(&quot;value&quot;, &quot;trend&quot;, &quot;seasonal&quot;, &quot;remainder&quot;)) # prepare data for plot componentTitles = c(&quot;Raw Data&quot;,&quot;Trend Component&quot;, &quot;Seasonal Component&quot;, &quot;Remainder&quot;) data &lt;- data %&gt;% dplyr::mutate(component = recode(component, value = componentTitles[1], trend = componentTitles[2], seasonal = componentTitles[3], remainder = componentTitles[4]), value = round(data$value, digits = 1)) %&gt;% rename(Value = value, Time = time) plot &lt;- ggplot(data) + geom_path(aes(x = Time, y = Value ), color = &quot;black&quot;, alpha = 0.7) + facet_wrap(~component, ncol = 1, scales = &quot;free_y&quot;) + scale_x_datetime(date_breaks = &quot;days&quot; , date_labels = &quot;%a\\n%d. %b\\n%H:%M&quot;) + theme_minimal() + theme(panel.spacing = unit(1, &quot;lines&quot;), legend.position = &quot;none&quot;) + labs(x = &quot;&quot;) + ggtitle(&quot;Time Series Decomposition over 5 days&quot;) ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/plotDecompositionShort.png&quot;, plot) "],["seasonal-plots.html", "Chapter 10 Seasonal Plots", " Chapter 10 Seasonal Plots Seasonal plots are a graphical tool to visualize and detect seasonality in a time series. Based on a selected periodicity it emphasizes the seasonal patterns and also shows the changes in seasonality over time. Especially, it allows to detect changes between different seasons. Figure 10.1: Seasonal Plot Overlapping per Month over 10 Years This is like a standard time series plot except that the data are plotted against the seasons for each year and are overlapping. Be aware that seasons in this context dont correlate with the seasons of the year. For example in 10.1 the seasons are months. When displaying the data in months, it is important that the consumption is calculated down to a daily value, otherwise there will be unnecessary distortions due to the different number of days per month. However, such plots are only useful if the period of the seasonality is already known. In many cases, this will in fact be known. For example, monthly data typically has a period of 12. If the period is not known, an autocorrelation plot or spectral plot can be used to determine it. This chapter shows some useful types of seasonal plots. "],["overlapping.html", "10.1 Overlapping", " 10.1 Overlapping 10.1.1 Goal Plot a seasonal plot as described in Hyndman and Athanasopoulos (2014, chapter 2.4): Figure 10.2: Seasonal Plot Overlapping per Month over 10 Years 10.1.2 Data Basis Figure 10.3: Raw Data for Seasonal Plot Overlapping 10.1.3 Solution Create a new script, copy/paste the following code and run it: library(forecast) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) library(viridis) library(lubridate) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% dplyr::mutate(value = lead(meterValue) - meterValue) # remove counter value column and calculate consumption per day instead of month df &lt;- df %&gt;% select(-meterValue) %&gt;% mutate(value = value /lubridate::days_in_month(timestamp)) # value correction (outlier because of commissioning) df[1,2] &lt;- 19 # create time series object for ggseanplot function df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 12, start = min(year(df$timestamp))) # create x/y plot numYears = length(unique(year(df$timestamp))) # used for colours plot &lt;- ggseasonplot(df.ts, col = viridis(numYears), main = &quot;Seasonal Plot x/y per Month over 10 years&quot;, ylab = &quot;Average Daily Energy Consumption per Month \\n(kWh/day)\\n&quot; ) # show static plot (uncomment it if you want a static plot) #plot # change theme (optional) plot &lt;- plot + ggthemes::theme_economist() # make plot interactive (optional) plotly &lt;- plotly::ggplotly(plot) # show plot interactive plot (optional) plotly # save static plot as png (optional) ggsave(&quot;images/plotSeasonalXY.png&quot;, plot) # save interactive plot as html (optional) library(htmlwidgets) htmlwidgets::saveWidget(plotly, &quot;plotlySeasonalXY.html&quot;) 10.1.4 Discussion A seasonal plot allows the underlying seasonal pattern to be seen more clearly, and is especially useful in identifying years in which the pattern changes. Hints: Double click on a specific year in the legend to display only that year Click once to activate/deactivate an element "],["mini-plots.html", "10.2 Mini Plots", " 10.2 Mini Plots 10.2.1 Goal Plot a seasonal month plot as described in Hyndman and Athanasopoulos (2014, chapter 2.5): Figure 10.4: Seasonal Plot with mini Time Plots over 10 Years Here the seasonal patterns for each season are collected together in seprate mini time plots. 10.2.2 Data Basis Figure 10.5: Raw Data for Seasonal Miniplots 10.2.3 Solution Create a new script, copy/paste the following code and run it: library(forecast) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) library(viridis) library(lubridate) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% dplyr::mutate(value = lead(meterValue) - meterValue) # remove counter value column and calculate consumption per day instead of month df &lt;- df %&gt;% select(-meterValue) %&gt;% mutate(value = value /lubridate::days_in_month(timestamp)) # value correction (outlier because of commissioning) df[1,2] &lt;- 19 # create time series object for ggmonthplot function df.ts &lt;- ts(df[-1], frequency = 12, start = min(year(df$timestamp))) # create x/y plot numYears = length(unique(year(df$timestamp))) plot &lt;- ggmonthplot(df.ts, col = viridis(numYears), main = &quot;Seasonal Miniplots over 10 years\\n&quot;, ylab = &quot;Average Daily Energy Consumption per Month \\n(kWh/day)\\n&quot;, xlab = &quot;Month\\n &quot; ) # change theme (optional) plot &lt;- plot + ggthemes::theme_economist() # make plot interactive (optional) plotly &lt;- plotly::ggplotly(plot) # show plot plotly # save static plot as png ggsave(&quot;images/plotSeasonalMiniplots.png&quot;, plot) # save interactive plot as html library(htmlwidgets) htmlwidgets::saveWidget(plotly, &quot;plotlySeasonalMiniplots.html&quot;) 10.2.4 Discussion This type of seasonal plot shows the mean value of each month and therefore emphasises on the monthly comparison It revelas as well the mean seasonal pattern with the blue lines "],["polar.html", "10.3 Polar", " 10.3 Polar 10.3.1 Goal Plot a seasonal plot as described in Hyndman and Athanasopoulos (2014, chapter 2.4): Figure 10.6: Seasonal Plot Polar per Month over 10 Years This is like an overlapping time series plot which uses polar coordinates. Be aware that seasons in this context dont correlate with the seasons of the year. 10.3.2 Data Basis Figure 10.7: Raw Data for Seasonal Plot Polar 10.3.3 Solution Create a new script, copy/paste the following code and run it: library(forecast) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) library(viridis) library(lubridate) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% dplyr::mutate(value = lead(meterValue) - meterValue) # remove counter value column and calculate consumption per day instead of month df &lt;- df %&gt;% select(-meterValue) %&gt;% mutate(value = value /lubridate::days_in_month(timestamp)) # value correction (outlier because of commissioning) df[1,2] &lt;- 19 df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 12, start = min(year(df$timestamp))) # create polar plot numYears = length(unique(year(df$timestamp))) plot &lt;- ggseasonplot(df.ts, col = viridis(numYears), main = &quot;Seasonal Plot Polar per Month over 10 Years\\n&quot;, ylab = &quot;Average Daily Energy Consumption per Month \\n(kWh/day)\\n&quot;, polar = TRUE ) # show plot (interactive version with plotly unfortunately not possible) plot # save static plot as png (optional) ggsave(&quot;images/plotSeasonalPolar.png&quot;, plot) 10.3.4 Discussion This representation emphasizes the high consumption in summer very well, which could undoubtedly be reduced in a residential building. The Years 2018 and 2019 show, that this optimization was done. To emphasize this optimization please refer to chapter 10.4. "],["dataVisSeasonalBefAft.html", "10.4 Before/After Optimization", " 10.4 Before/After Optimization 10.4.1 Goal To highlight an energy optimization in a season diagram, we can gray out the seasons before the optimization and only highlight the monthly values after the optimization. To better quantify the success, we can calculate and display the confidence interval of the years before. We will create the following plot: Figure 10.8: Seasonal Plot Overlapping Before/After 10.4.2 Data Basis Figure 10.9: Raw Data for Seasonal Plot Overlapping Before/After Optimization 10.4.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% dplyr::mutate(value = lead(meterValue) - meterValue) # remove counter value column and calculate consumption per day instead of month df &lt;- df %&gt;% select(-meterValue) %&gt;% mutate(value = value /lubridate::days_in_month(timestamp)) # value correction (outlier because of commissioning) df[1,2] &lt;- 19 # create plot plot &lt;- plotSeasonalXYBeforeAfter(df, dateOptimization = &quot;2017-09-01&quot;, locTimeZone = &quot;Europe/Zurich&quot;, main = &quot;Before/After Optimization&quot;, ylab = &quot;Average Daily Energy Consumption per Month \\n(kWh/day)\\n&quot; ) # change theme (optional) plot &lt;- plot + ggthemes::theme_economist() # make plot interactive (optional) plotly &lt;- plotly::ggplotly(plot) # show plot plotly # save interactive plot as html (optional) library(htmlwidgets) htmlwidgets::saveWidget(plotly, &quot;plotEnergyConsBeforeAfter.png&quot;) 10.4.4 Discussion One can clearly see the impact of the optimization in mid-2017 And as well the too low setting of January 2018 where the thermostat of the flat got deactivated The confidence band shows as well the year 2013 which had an unusual high consumption from February to June "],["heat-maps.html", "Chapter 11 Heat Maps", " Chapter 11 Heat Maps Temporal patterns can show at what time certain devices are exposed to how much load. Heatmaps show quantitative values based on two axes. These can be day and hours, month and day, etc. The cell at the intersection contains the corresponding value. Depending on the context, this can be an average value, a maximum/minimum value, etc. Heatmaps allow the viewer to see short-term patterns and long-term trends in the data with a higher temporal granularity. This chapter shows different types of heat maps which are useful for energy data analysis and pattern recognition. "],["calendar.html", "11.1 Calendar", " 11.1 Calendar 11.1.1 Goal Create a calendar heat map with daily energy consumption values: Figure 11.1: Calendar Heat Map 11.1.2 Data Basis Daily energy consumption values of one whole year in an interval of 15mins. Figure 11.2: Raw Data for Decomposition Plot Short Term 11.1.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(ggTimeSeries) library(plotly) library(lubridate) library(dplyr) library(tidyquant) data &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) data &lt;- data[-nrow(data),] data$timestamp &lt;- parse_date_time(data$timestamp, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) data$day &lt;- as.Date(lubridate::floor_date(data$timestamp,&quot;day&quot;)) data &lt;- data %&gt;% select(-timestamp) data.plot &lt;- data %&gt;% dplyr::group_by(day) %&gt;% dplyr::mutate(calcVal = sum(value, na.rm = TRUE)) %&gt;% ungroup() %&gt;% select(-value) %&gt;% unique() plot &lt;- ggplot_calendar_heatmap(data.plot, &quot;day&quot;, &quot;calcVal&quot;, monthBorderSize = 1, monthBorderColour = &quot;white&quot;, monthBorderLineEnd = &quot;square&quot;) + scale_fill_viridis_c(option = &quot;B&quot;) + theme_minimal() + theme(axis.title.y = element_text(colour = &quot;grey30&quot;, size = 10, face = &quot;plain&quot;), )+ labs(x = &quot;\\nMonth&quot;, y = &quot;Energy Consumption\\n(kWh/d)\\n &quot;, fill = &quot;Legend&quot;) + facet_wrap(~Year, ncol = 1) + ggtitle(&quot;Calendar Plot Energy Consumption\\n&quot;) plot # create the interactive plot (optional, uncomment line) #ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/plotHeatMapCalendar.png&quot;, plot) 11.1.4 Discussion Some findings: first two days in year minimal consumption 6th of April: Easter Monday 25th of May: Whitmonday (de: Pfingstmontag) More usage in August In November one Sunday with unusual high consumption On Fridays in general less consumption "],["median-weeks.html", "11.2 Median-Weeks", " 11.2 Median-Weeks 11.2.1 Goal Create an energy consumption heat map of a median week depending on the season of the year: Figure 11.3: Heat Map of Median Weeks per Season of Year 11.2.2 Data Basis Daily energy consumption values of one whole year in an interval of 15mins. Figure 11.4: Raw Data for Decomposition Plot Short Term 11.2.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(plotly) data &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) plot &lt;- plotHeatmapMedianWeeks(data, locTimeZone = &quot;Europe/Zurich&quot;) # show the static plot plot # create the interactive plot (optional, uncomment line) #ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/plotHeatMapMedianWeeks.png&quot;, plot) 11.2.4 Discussion Some findings: Increased consumption at midnight, but not visible in Summer, probably heating affected Clearly less consumption at weekends, starting already friday afternoon High peaks on Tuesdays and Thursdays in summer "],["typical-daily-profiles.html", "Chapter 12 Typical Daily Profiles", " Chapter 12 Typical Daily Profiles An important step in energy data analysis is the recognition of patterns. For this purpose, the data are first aggregated to hourly values, averaged and displayed as typical daily patterns. The daily profiles can be displayed separately for the weekdays and the seasons. This chapter shows some useful visualizations to accommodate this recognition. "],["overview.html", "12.1 Overview", " 12.1 Overview 12.1.1 Goal Create an overview of typical daily profiles per weekday and season of year with a confidence band where most of the values lie: Figure 12.1: Overview of Daily Profiles by Weekday and Season 12.1.2 Data Basis Energy consumption values of one whole year in an interval of 15mins. Figure 12.2: Raw Data for Decomposition Plot Short Term 12.1.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(dplyr) library(lubridate) library(redutils) library(ggplot2) library(plotly) # load time series data df &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) plot &lt;- plotDailyProfilesOverview(df, locTimeZone = &quot;Europe/Zurich&quot;, main = &quot;Daily Profiles Overview by Weekday and Season&quot;, ylab = &quot;Power (kW)&quot;, col = &quot;black&quot;, confidence = 95.0) ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/plotDailyProfOverview.png&quot;, plot) "],["overlayed.html", "12.2 Overlayed", " 12.2 Overlayed 12.2.1 Goal Create a plot of all data per week by season of the year: Figure 12.3: Overlayed Daily Profiles 12.2.2 Data Basis Energy consumption values of one whole year in an interval of 15mins. Figure 12.4: Raw Data for Decomposition Plot Short Term 12.2.3 Solution Create a new script, copy/paste the following code and run it: # change language to English, otherwise weekdays are in local language Sys.setlocale(&quot;LC_TIME&quot;, &quot;English&quot;) ## [1] &quot;English_United States.1252&quot; library(plotly) library(dplyr) library(lubridate) # load time series data df &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) df &lt;- dplyr::mutate(df, value = value * 4) # add metadata for later grouping and visualization purposes df$x &lt;- hour(df$timestamp) + minute(df$timestamp)/60 + second(df$timestamp) / 3600 df$weekday &lt;- weekdays(df$timestamp) df$weekday &lt;- factor(df$weekday, c(&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;, &quot;Sunday&quot;)) df$day &lt;- as.Date(df$timestamp, format = &quot;%Y-%m-%d %H:%M:%S&quot;) df &lt;- df %&gt;% dplyr::mutate(value = ifelse(x == 0.00, NA, df$value)) # plot graph with all time series rangeX &lt;- seq(0,24,0.25) maxValue &lt;- max(df$value, na.rm = TRUE)*1.05 plot &lt;- df %&gt;% highlight_key(~day) %&gt;% plot_ly(x=~x, y=~value, color=~weekday, type=&quot;scatter&quot;, mode=&quot;lines&quot;, line = list(width = 1), alpha = 0.15, colors = &quot;dodgerblue4&quot;, text = ~day, hovertemplate = paste(&quot;Time: &quot;, format(df$timestamp, &quot;%H:%M&quot;), &quot;&lt;br&gt;Date: &quot;, format(df$timestamp, &quot;%Y-%m-%d&quot;), &quot;&lt;br&gt;Value: %{y:.0f}&quot;)) %&gt;% # workaround with add_trace to have fixed y axis when selecting a dedicated day add_trace(x = 0, y = 0, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% add_trace(x = 24, y = maxValue, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% layout(title = &quot;Daily Profiles - Overlayed&quot;, showlegend = TRUE, xaxis = list( title = &quot;Hour of day&quot;, range = rangeX, tickvals = list(0, 3, 6, 9, 12, 15, 18, 21), showline=TRUE ), yaxis = list( title = &quot;Power (kW)&quot;, range = c(0, maxValue) ) ) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;, color = &quot;orange&quot;, opacityDim = 1.0, selected = attrs_selected(showlegend = FALSE)) %&gt;% # this hides elements in the legend plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE) # show plot plot "],["mean.html", "12.3 Mean", " 12.3 Mean 12.3.1 Goal Create a plot of mean data per week: Figure 12.5: Mean Daily Profiles per Weekday 12.3.2 Data Basis Energy consumption values of one whole year in an interval of 15mins. Figure 12.6: Raw Data for Decomposition Plot Short Term 12.3.3 Solution Create a new script, copy/paste the following code and run it: # change language to English, otherwise weekdays are in local language Sys.setlocale(&quot;LC_TIME&quot;, &quot;English&quot;) ## [1] &quot;English_United States.1252&quot; library(plotly) library(dplyr) library(lubridate) # load time series data df &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) df &lt;- dplyr::mutate(df, value = value * 4) # add metadata for later grouping and visualization purposes df$x &lt;- hour(df$timestamp) + minute(df$timestamp)/60 + second(df$timestamp) / 3600 df$weekday &lt;- weekdays(df$timestamp) df$weekday &lt;- factor(df$weekday, c(&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;, &quot;Sunday&quot;)) df &lt;- df %&gt;% dplyr::mutate(value = ifelse(x == 0.00, NA, df$value)) # Calculate Mean value for all 15 minutes for each weekday df &lt;- df %&gt;% group_by(weekday, x) %&gt;% dplyr::mutate(dayTimeMean = mean(value)) %&gt;% ungroup() # shrink data frame df &lt;- df %&gt;% select(x, weekday, timestamp, dayTimeMean) %&gt;% unique() %&gt;% na.omit() %&gt;% arrange(weekday, x) # plot graph with mean values maxValMean &lt;- max(df$dayTimeMean, na.rm = TRUE)*1.05 plot &lt;- df %&gt;% highlight_key(~weekday) %&gt;% plot_ly(x=~x, y=~dayTimeMean, color=~weekday, type=&quot;scatter&quot;, mode=&quot;lines&quot;, alpha = 0.25, colors = &quot;dodgerblue4&quot;, text = ~weekday, hovertemplate = paste(&quot;Time: &quot;, format(df$timestamp, &quot;%H:%M&quot;), &quot;&lt;br&gt;Mean: %{y:.0f}&quot;)) %&gt;% # workaround with add_trace to have fixed y axis when selecting a dedicated day add_trace(x = 0, y = 0, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% add_trace(x = 24, y = maxValMean, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% layout(title = &quot;Daily Profiles - Mean&quot;, showlegend = TRUE, xaxis = list( title = &quot;Hour of day&quot;, tickvals = list(0, 3, 6, 9, 12, 15, 18, 21) ), yaxis = list( title = &quot;Power (kW)&quot;, range = c(0, maxValMean) ) ) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;, color = &quot;orange&quot;, opacityDim = 0.7, selected = attrs_selected(showlegend = FALSE)) %&gt;% # this hides elements in the legend plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE) # show plot plot "],["dailyProfilesDecomposed.html", "12.4 Decomposed", " 12.4 Decomposed 12.4.1 Goal Create a plot of detrended mean data per week as recommended in Building electricity consumption: Data analytics of building operations with classical time series decomposition and case based subsetting, Pickering et al, 2018: Figure 12.7: Mean Daily Profiles per Weekday 12.4.2 Data Basis Energy consumption values of one whole year in an interval of 15mins. Figure 12.8: Raw Data for Decomposition Plot Short Term 12.4.3 Solution Create a new script, copy/paste the following code and run it: library(plotly) library(redutils) # load time series data df &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) df &lt;- dplyr::mutate(df, value = value * 4) plot &lt;- plotDailyProfilesDecomposed(df, locTimeZone = &quot;Europe/Zurich&quot;) ggplotly(plot) # save static plot as png (optional) ggsave(&quot;images/plotDailyProfDecomposed.png&quot;, plot) "],["sum-frequency-diagrams.html", "Chapter 13 Sum Frequency Diagrams", " Chapter 13 Sum Frequency Diagrams This type of visualization has a long tradition in energy data analyses and various calculation methods are still based on it. "],["sum-frequency-days.html", "13.1 Sum Frequency Days", " 13.1 Sum Frequency Days 13.1.1 Goal You want to create a sum frequency plot of a temperature series for each day in a year: Figure 13.1: Sum Frequency Plot Temperature Days 13.1.2 Data Basis Figure 13.2: Outside Temperature Raw Data for Sum Frequency Days Plot 13.1.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) library(lubridate) library(zoo) library(mgcv) # load time series data and aggregate daily mean values df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) df$time &lt;- parse_date_time(df$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # rename columns colnames(df) &lt;- c(&quot;time&quot;, &quot;value&quot;) df$day &lt;- as.Date(cut(df$time, breaks = &quot;day&quot;)) df$year &lt;- year(df$time) # filter year filterYear &lt;- &quot;2019&quot; df &lt;- filter(df, year == filterYear) df &lt;- df %&gt;% group_by(day) %&gt;% dplyr::summarise(meanValue = mean(value, na.rm = TRUE)) %&gt;% ungroup() # Fill missing values with NA grid.df &lt;- data.frame(day = seq(as.Date(paste0(filterYear, &quot;-01-01&quot;)), as.Date(paste0(filterYear, &quot;-12-31&quot;)), by = &quot;days&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # replace NA with interpolation df$meanValue &lt;- na.approx(df$meanValue) tempMin &lt;- floor(min(df$meanValue, na.rm = TRUE)) tempMax &lt;- ceiling(max(df$meanValue, na.rm = TRUE)) # create new data frame with sorted values data &lt;- data.frame(sort(df$meanValue)) data$day &lt;- as.numeric(row.names(data)) colnames(data) &lt;- c(&quot;meanValue&quot;, &quot;day&quot;) # static chart with ggplot plot &lt;- ggplot2::ggplot(data) + ggplot2::geom_point(aes(x = day, y = meanValue), colour = &quot;orange&quot;, alpha = 0.8, size = 0.5 ) + ggtitle(&quot;Sum Frequency Plot for each Day in a Year&quot;) + ylab(&quot;Mean Temperature (\\u00B0C)\\n&quot;) + xlab(&quot;\\nFrequency (days)&quot;) + theme_minimal() + scale_x_continuous(breaks = append(seq(0, 365, 25), 365)) + scale_y_continuous(breaks = seq(tempMin, tempMax, 2)) # interactive chart plotly::ggplotly(plot) # save static plot as png ggsave(&quot;images/plotSumFrequencyDays.png&quot;, plot) "],["sum-frequency-hours.html", "13.2 Sum Frequency Hours", " 13.2 Sum Frequency Hours 13.2.1 Goal You want to create a sum frequency plot of a temperature series for each hour in a year: Figure 13.3: Sum Frequency Plot Temperature 13.2.2 Data Basis Figure 13.4: Outside Temperature Raw Data for Sum Frequency Hours Plot 13.2.3 Solution Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) library(lubridate) library(zoo) # load time series data and aggregate daily mean values df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) df$time &lt;- parse_date_time(df$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # rename columns colnames(df) &lt;- c(&quot;time&quot;, &quot;value&quot;) df$day &lt;- as.Date(cut(df$time, breaks = &quot;day&quot;)) df$hour &lt;- as.POSIXct(cut(df$time, breaks = &quot;hour&quot;), tz = &quot;Europe/Zurich&quot;) df$year &lt;- year(df$time) # filter year # edit year!!! filterYear &lt;- &quot;2019&quot; df &lt;- filter(df, year == filterYear) df &lt;- df %&gt;% group_by(hour) %&gt;% dplyr::summarise(meanValue = mean(value, na.rm = TRUE)) %&gt;% ungroup() # Fill missing values with NA grid.df &lt;- data.frame(hour = seq(as.POSIXct(paste0(filterYear, &quot;-01-01 00:00:00&quot;), tz = &quot;Europe/Zurich&quot;), as.POSIXct(paste0(filterYear, &quot;-12-31 23:00:00&quot;), tz = &quot;Europe/Zurich&quot;), by = &quot;hours&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # replace NA with interpolation df$meanValue &lt;- na.approx(df$meanValue) tempMin &lt;- floor(min(df$meanValue, na.rm = TRUE)) tempMax &lt;- ceiling(max(df$meanValue, na.rm = TRUE)) # create new data frame with sorted values data &lt;- data.frame(sort(df$meanValue)) data$hour &lt;- as.numeric(row.names(data)) colnames(data) &lt;- c(&quot;meanValue&quot;, &quot;hour&quot;) # static chart with ggplot plot &lt;- ggplot2::ggplot(data) + ggplot2::geom_point(aes(x = hour, y = meanValue), colour = &quot;orange&quot;, alpha = 0.3, size = 0.5 ) + ggtitle(&quot;Sum Frequency Plot for each Hour in a Year&quot;) + ylab(&quot;Mean Temperature (\\u00B0C)\\n&quot;) + xlab(&quot;\\nFrequency (hours)&quot;) + theme_minimal() + scale_x_continuous(breaks = append(seq(0, 8760, 1000), 8760)) + scale_y_continuous(breaks = seq(tempMin, tempMax, 2)) # interactive chart plotly::ggplotly(plot) # save static plot as png ggsave(&quot;images/plotSumFrequencyHour.png&quot;, plot) "],["comfort-plots.html", "Chapter 14 Comfort Plots", " Chapter 14 Comfort Plots Satisfied and healthy residents are important, so energetic optimization should improve comfort as much as possible and certainly not adversely affect it. For this reason, the so-called comfort monitoring is gaining more and more importance. The visualizations in this part focus on some typical comfort related visualizations. "],["mollier-hx-diagram.html", "14.1 Mollier hx Diagram", " 14.1 Mollier hx Diagram 14.1.1 Goal You want to plot a mollier h-x diagram: Figure 14.1: Mollier hx Diagram with comfort zone 14.1.2 Data Basis Figure 14.2: Raw Data Temperature and Humidity for Mollier hx Diagram Figure 14.3: Raw Data Temperature and Humidity for Mollier hx Diagram 14.1.3 Solution The sensor data is not in a constant intervall and not yet aggregated. So after reading in the time series the data has to get filtered and aggregated per day. Finally use the plot function mollierHxDiagram from the redutils package (R Energy Data Utilities). If you have not yet installed this package, proceed as follows: install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;hslu-ige-laes/redutils&quot;) Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) # read and print data data &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and humidity and remove empty cells data &lt;- data %&gt;% select(time, FlatA_Temp, FlatA_Hum) %&gt;% na.omit() # create column with day for later grouping data$time &lt;- parse_date_time(data$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) data$day &lt;- as.Date(cut(data$time, breaks = &quot;day&quot;)) # calculate daily mean of temperature and humidity data &lt;- data %&gt;% group_by(day) %&gt;% summarize(tempMean = mean(as.numeric(FlatA_Temp)), humMean = mean(as.numeric(FlatA_Hum)) ) %&gt;% ungroup() # plot mollier hx diagram plot &lt;- plotMollierHx(data) # show plot plot 14.1.4 See also If you are interested in implementing this plot in your own dashboard you can check the free D3 implementation of it: https://github.com/hslu-ige-laes/d3-mollierhx "],["temperature-versus-humidity.html", "14.2 Temperature versus Humidity", " 14.2 Temperature versus Humidity 14.2.1 Goal You want to create a temperature versus humidity comfort plot: Figure 14.4: Temperature versus Humidity Comfort Plot 14.2.2 Data Basis Figure 14.5: Raw Data Temperature and Humidity for Temp vs. Hum Comfort Plot Figure 14.6: Raw Data Temperature and Humidity for Temp vs. Hum Comfort Plot 14.2.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(plyr) # read and print data data &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and humidity and remove empty cells data &lt;- data %&gt;% select(time, FlatA_Temp, FlatA_Hum) %&gt;% na.omit() colnames(data) &lt;- c(&quot;time&quot;, &quot;tempRaw&quot;, &quot;humidityRaw&quot;) # create column with day for later grouping data$time &lt;- parse_date_time(data$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) data$day &lt;- as.Date(cut(data$time, breaks = &quot;day&quot;)) # calculate daily mean of temperature and humidity data &lt;- data %&gt;% group_by(day) %&gt;% dplyr::summarize(temperature = mean(as.numeric(tempRaw), na.rm = TRUE), humidity = mean(as.numeric(humidityRaw), na.rm = TRUE) ) %&gt;% ungroup() %&gt;% na.omit() # calculate season data$day &lt;- parse_date_time(data$day, &quot;Ymd&quot;, tz = &quot;Europe/Zurich&quot;) data$season &lt;- getSeason(data$day) # create plot # axis properties minx &lt;- floor(min(14.0,min(data$temperature))) maxx &lt;- ceiling(max(28.0,max(data$temperature))) miny &lt;- 0.0 maxy &lt;- 100.0 # comfort zones df.zoneNotComfortable &lt;- data.frame(Temp = c(minx,minx,maxx, maxx, minx), Hum = c(miny,maxy,maxy, miny, miny), Zones = &quot;uncomfortable&quot;) df.zoneStillComfortable &lt;- data.frame(Temp = c(20,17,16,17,21.5,25,27,25.5,20), Hum = c(20,40,75,85,80,60,30,20,20), Zones = &quot;Still comfortable&quot;) df.zoneComfortable &lt;- data.frame(Temp = c(19,17.5,22.5,24,19), Hum = c(38,74,65,35,38), Zones = &quot;Comfortable&quot;) df.zones &lt;- rbind.fill(df.zoneNotComfortable, df.zoneStillComfortable) df.zones &lt;- rbind.fill(df.zones, df.zoneComfortable) plot &lt;- ggplot() + geom_polygon(data = df.zoneStillComfortable, aes(x = Temp, y = Hum), alpha = 0.25, color = &quot;orange&quot;, fill = &quot;orange&quot;, name = &quot;Comofort Zone&quot;) + geom_polygon(data = df.zoneComfortable, aes(x = Temp, y = Hum), alpha = 0.4, color = &quot;yellowgreen&quot;, fill = &quot;yellowgreen&quot;) + geom_point(data = data, aes(x = temperature, y = humidity, fill = season, colour = season, text = paste0(&quot;Temp: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, temperature), &quot;&lt;br /&gt;Hum: &quot;, sprintf(&quot;%.1f %%rH&quot;, humidity), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season) ), alpha = 0.4) + ggtitle(&quot;Temperature versus Humidity Comfort Plot&quot;) + labs(x = &quot;\\nTemperature (\\u00B0C)&quot;, y = &quot;Humidity (%rH)\\n&quot;, fill = &quot;&quot;, colour = &quot;Legend&quot;) + scale_x_continuous(breaks = seq(minx, maxx, 2), limits = c(minx, maxx)) + scale_y_continuous(breaks = seq(miny, maxy, 20), limits = c(miny, maxy)) + scale_color_manual(values = c(&quot;#440154&quot;, &quot;#2db27d&quot;, &quot;#febc2b&quot;, &quot;#365c8d&quot;)) + scale_fill_manual(values = c(&quot;#440154&quot;, &quot;#2db27d&quot;, &quot;#febc2b&quot;, &quot;#365c8d&quot;)) + theme_minimal() # interactive chart ggplotly(plot, tooltip = &quot;text&quot;) # save static plot as png #ggsave(&quot;images/comfortTempHum.png&quot;, plot) "],["sia-180-thermal-comfort.html", "14.3 SIA 180 Thermal Comfort", " 14.3 SIA 180 Thermal Comfort 14.3.1 Goal You want to plot a diagram like the one from the SIA 180:2014 Figure 14.7: Thermal Comfort according to SIA 180:2014 14.3.2 Data Basis Figure 14.8: Raw Data Room and Outdoor Temperature for SIA180 Thermal Comfort Plot Figure 14.9: Raw Data Room and Outdoor Temperature for SIA180 Thermal Comfort Plot 14.3.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(zoo) library(plotly) # load time series data and aggregate mean values dfTempOa &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfTempOa$time &lt;- parse_date_time(dfTempOa$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) dfTempOa$hour &lt;- cut(dfTempOa$time, breaks = &quot;hour&quot;) dfTempOa &lt;- dfTempOa %&gt;% group_by(hour) %&gt;% dplyr::mutate(tempMean = mean(centralOutsideTemp)) %&gt;% ungroup() %&gt;% select(time, tempMean) %&gt;% unique() # Fill missing values with NA grid.df &lt;- data.frame(time = seq(min(dfTempOa$time, na.rm = TRUE), max(dfTempOa$time, na.rm = TRUE), by = &quot;hour&quot;)) dfTempOa &lt;- merge(dfTempOa, grid.df, all = TRUE) dfTempOa &lt;- dfTempOa %&gt;% dplyr::mutate(tempOa = rollmean(tempMean, 48, fill = NA, align = &quot;right&quot;)) dfTempOa &lt;- dfTempOa %&gt;% select(time, tempOa) %&gt;% unique() %&gt;% na.omit() dfTempR &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfTempR$time &lt;- parse_date_time(dfTempR$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) # select temperature and humidity and remove empty cells dfTempR &lt;- dfTempR %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() dfTempR$hour &lt;- cut(dfTempR$time, breaks = &quot;hour&quot;) dfTempR &lt;- dfTempR %&gt;% group_by(hour) %&gt;% dplyr::mutate(tempR = mean(FlatA_Temp)) %&gt;% ungroup() %&gt;% select(time, tempR) %&gt;% unique() # Fill missing values with NA grid.df &lt;- data.frame(time = seq(min(dfTempR$time, na.rm = TRUE), max(dfTempR$time, na.rm = TRUE), by = &quot;hour&quot;)) dfTempR &lt;- merge(dfTempR, grid.df, all = TRUE) data &lt;- merge(dfTempR, dfTempOa, all = TRUE) %&gt;% unique() %&gt;% na.omit() data$season &lt;- redutils::getSeason(data$time) # plot diagram # axis properties minx &lt;- floor(min(0, min(data$tempOa))) maxx &lt;- ceiling(max(28, max(data$tempOa))) miny &lt;- floor(min(21.0,min(data$tempR)))-1 maxy &lt;- ceiling(max(32.0,max(data$tempR)))+1 # line setpoint heat df.heatSp &lt;- data.frame(tempOa = c(minx, 19, 23.5, maxx), tempR = c(20.5, 20.5, 22, 22)) # line setpoint cool according to SIA 180:2014 Fig. 4 df.coolSp1 &lt;- data.frame(tempOa = c(minx, 12, 17.5, maxx),tempR = c(24.5, 24.5, 26.5, 26.5)) # line setpoint cool according to SIA 180:2014 Fig. 3 df.coolSp2 &lt;- data.frame(tempOa = c(minx, 10, maxx),tempR = c(25, 25, 0.33 * maxx + 21.8)) plot &lt;- data %&gt;% plot_ly(showlegend = TRUE) %&gt;% add_lines(data = df.coolSp2, x = ~tempOa, y = ~tempR, name = &quot;Upper limit SIA 180 passive cooling&quot;, opacity = 0.7, color = &quot;#FDE725FF&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Upper limit SIA 180 passive cooling&quot;, &quot;&lt;br /&gt;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa) ) ) %&gt;% add_lines(data = df.coolSp1, x = ~tempOa, y = ~tempR, name = &quot;Upper limit SIA 180 active cooling&quot;, opacity = 0.7, color = &quot;#1E9B8AFF&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Upper limit SIA 180 active cooling&quot;, &quot;&lt;br /&gt;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa) ) ) %&gt;% add_lines(data = df.heatSp, x = ~tempOa, y = ~tempR, name = &quot;Lower Limit SIA 180&quot;, opacity = 0.7, color = &quot;#440154FF&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Lower Limit SIA 180&quot;, &quot;&lt;br /&gt;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa) ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Spring&quot;), x = ~tempOa, y = ~tempR, name = &quot;Spring&quot;, marker = list(color = &quot;#2db27d&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Summer&quot;), x = ~tempOa, y = ~tempR, name = &quot;Summer&quot;, marker = list(color = &quot;#febc2b&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Fall&quot;), x = ~tempOa, y = ~tempR, name = &quot;Fall&quot;, marker = list(color = &quot;#440154&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Winter&quot;), x = ~tempOa, y = ~tempR, name = &quot;Winter&quot;, marker = list(color = &quot;#365c8d&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% layout( title = &quot;Thermal Comfort according to SIA 180:2014&quot;, xaxis = list(title = &quot;Moving average outdoor temperature over last 48 hours (\\u00B0C)&quot;, range = c(minx, maxx), zeroline = FALSE, tick0 = minx, dtick = 2, titlefont = list(size = 14, color = &quot;darkgrey&quot;)), yaxis = list(title = &quot;Room Temperature (\\u00B0C)&quot;, range = c(miny, maxy), dtick = 1, titlefont = list(size = 14, color = &quot;darkgrey&quot;)), hoverlabel = list(align = &quot;left&quot;), margin = list(l = 80, t = 50, r = 50, b = 10), legend = list(orientation = &#39;h&#39;, x = 0.0, y = -0.3) ) %&gt;% plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE, toImageButtonOptions = list( format = &quot;png&quot; ) ) # show plot plot "],["miscellaneous.html", "Chapter 15 Miscellaneous", " Chapter 15 Miscellaneous Finally, some visualizations that did not fit into any of the above chapters and are not (yet) worth a separate chapter. But these are not less interesting "],["electricity-household.html", "15.1 Electricity Household", " 15.1 Electricity Household 15.1.1 Goal You want to plot an electricity consumption diagram with: upper plot with daily energy consumption in kWh/day lower plot with standby-losses in Watts Additionaly we would like to see the consumption of an average Swiss household. Figure 15.1: Plot Electricity Household 15.1.2 Data Basis A csv file with time series of an electric meter in 15 minute interval. Figure 15.2: Raw Data for Electricity Household Plot 15.1.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(zoo) library(plotly) # load time series data and aggregate mean values df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatElectricity.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) df$time &lt;- parse_date_time(df$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) # select room df &lt;- df %&gt;% select(time, FlatC_Ele) # rename columns colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # filter timerange df &lt;- df %&gt;% filter(timestamp &gt; &quot;2019-07-01&quot;) # Fill missing values with NA grid.df &lt;- data.frame(timestamp = seq(min(df$timestamp, na.rm = TRUE), max(df$timestamp, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% dplyr::mutate(value = (meterValue - lag(meterValue))) %&gt;% select(-meterValue) # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) # determine date related parameters for later filtering df$day &lt;- as.Date(df$time, tz = &quot;UTC&quot;) df$week &lt;- lubridate::week(df$time) df$month &lt;- lubridate::month(df$time) df$year &lt;- lubridate::year(df$time) # data cleansing # tag NA df &lt;- df %&gt;% dplyr::mutate(deleteNA = ifelse(is.na(value),1,0)) # tag values below 0 and higher than 9.2 kW df &lt;- df %&gt;% dplyr::mutate(deleteHiLoVal = ifelse(value &gt; 9.2,1, ifelse(value &lt; 0,1,0))) # Assumption max. fuse 40 ampere (higher fuses for single family houses) # this results in continuous power 9.2 kW # this results in an hourly consumption of 9.2kWh # over 24h = approx. 221 kWh max. consumption per day # tag whole days which have one or more values to delete, keep only whole valid days df &lt;- df %&gt;% group_by(day) %&gt;% dplyr::mutate(delete = sum(deleteNA, na.rm = TRUE) + sum(deleteHiLoVal, na.rm = TRUE)) df &lt;- df %&gt;% ungroup() # delete full days with invalid data df &lt;- df %&gt;% filter(delete == 0) %&gt;% select(-deleteNA, -deleteHiLoVal, -delete) # determine season for later filtering df &lt;- df %&gt;% dplyr::mutate(season = redutils::getSeason(timestamp)) # calculate sum and min per day df &lt;- df %&gt;% dplyr::group_by(day) %&gt;% dplyr::mutate(sum = sum(value)) df &lt;- df %&gt;% dplyr::group_by(day) %&gt;% dplyr::mutate(min = min(value)*1000*4) df &lt;- df %&gt;% ungroup() df &lt;- df %&gt;% dplyr::select(day, sum, min, season) %&gt;% unique() df &lt;- df %&gt;% dplyr::mutate(ravgUsage = zoo::rollmean(x=sum, 7, fill = NA)) df &lt;- df %&gt;% dplyr::mutate(rminStandby = -1 * zoo::rollmaxr(x = -1 * min, 7, fill = NA)) typEleConsVal &lt;- redutils::getTypEleConsHousehold(occupants = 2, rooms = 3.5, bldgType = &quot;multi&quot;, laundry = &quot;hotWaterSupply&quot;)/365 # Plot main = &quot;Electricity consumption private household&quot; minY &lt;- 0 maxYUsage &lt;- max(df %&gt;% select(sum), na.rm=TRUE) maxYUsage &lt;- max(maxYUsage, typEleConsVal/365) maxYStandby &lt;- max(max(df %&gt;% select(min), na.rm=TRUE), 0.25*maxYUsage/24*1000) minX &lt;- min(df$day) maxX &lt;- max(df$day) averageUsage &lt;- mean(df$sum, na.rm=TRUE) averageStandby &lt;- mean(df$rminStandby, na.rm=TRUE) shareStandby &lt;- nrow(df %&gt;% select(sum) %&gt;% na.omit()) * averageStandby * 24 / (1000 * sum(df$sum, na.rm=TRUE)) * 100 # legend l &lt;- list( orientation = &quot;h&quot;, tracegroupgap = &quot;20&quot;, font = list(size = 8), xanchor = &quot;center&quot;, x = 0.5, itemclick = FALSE ) fig1 &lt;- df %&gt;% plot_ly(x = ~day, showlegend = TRUE) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Spring&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Spring&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#2db27d&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;daily usage: &quot;, sprintf(&quot;%.1f kWh/d&quot;, sum), &quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Summer&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Summer&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#febc2b&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Fall&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Fall&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#440154&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Winter&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Winter&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#365c8d&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df, type = &quot;scatter&quot;, mode = &quot;markers&quot;, y = ~ravgUsage, name = &quot;Average Cons. (7 days)&quot;, legendgroup = &quot;group2&quot;, marker = list(color = &quot;orange&quot;, opacity = 0.4, symbol = &quot;circle&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~averageUsage, yend = ~averageUsage, name = &quot;Average Cons. Total&quot;, legendgroup = &quot;group2&quot;, line = list(color = &quot;orange&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~averageStandby*24/1000, yend = ~averageStandby*24/1000, name = &quot;Average Standby Total&quot;, legendgroup = &quot;group3&quot;, showlegend = FALSE, line = list(color = &quot;black&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;Average standby power: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;equals to daily energy: &quot;, sprintf(&quot;%.1f kWh&quot;, averageStandby*24/1000), &quot;&lt;br /&gt;Standby percent of total cons.: &quot;, sprintf(&quot;%.0f %%&quot;, shareStandby) ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~typEleConsVal, yend = ~typEleConsVal, name = &quot;typical household&quot;, legendgroup = &quot;group4&quot;, line = list(color = &quot;#481567FF&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;typical household: &quot;, sprintf(&quot;%.0f kWh/year&quot;, typEleConsVal*365), &quot;&lt;br /&gt;equals to daily energy: &quot;, sprintf(&quot;%.1f kWh/day&quot;, typEleConsVal), &quot;&lt;br /&gt;consumption of current flat: &quot;, sprintf(&quot;%.1f kWh/day&quot;, averageUsage) ) ) %&gt;% add_annotations( x = minX, y = typEleConsVal, text = paste0(&quot;typical comparable household &quot;, sprintf(&quot;%.1f kWh/d&quot;, typEleConsVal)), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = 100, ay = -20, font = list(color = &quot;#481567FF&quot;) ) %&gt;% add_annotations( x = maxX, y = averageUsage, text = paste0(&quot;Average consumption &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage)), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = -100, ay = -60, font = list(color = &quot;orange&quot;) ) %&gt;% add_annotations( x = maxX, y = averageStandby*24/1000, text = paste0(sprintf(&quot;%.1f %%&quot;, shareStandby), &quot; of the consumption are standby-losses&quot;), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = -160, ay = -15, font = list(color = &quot;black&quot;) ) %&gt;% layout( title = main, xaxis = list( title = &quot;&quot; ), yaxis = list(title = &quot;Consumption&lt;br&gt;(kWh/d)&quot;, range = c(minY, maxYUsage), titlefont = list(size = 14, color = &quot;darkgrey&quot;)), hoverlabel = list(align = &quot;left&quot;), margin = list(l = 80, t = 50, r = 50, b = 10), legend = l ) fig2 &lt;- df %&gt;% plot_ly(x = ~day, showlegend = TRUE) %&gt;% add_trace(data = df, type = &quot;bar&quot;, y = ~min, name = &quot;Daily standby-losses&quot;, legendgroup = &quot;group3&quot;, marker = list(color = &quot;darkgrey&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;daily standby: &quot;, sprintf(&quot;%.0f W&quot;, min), &quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.0f W&quot;, rminStandby), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df, type = &quot;scatter&quot;, mode = &quot;markers&quot;, y = ~rminStandby, name = &quot;Average Standby (7 days)&quot;, legendgroup = &quot;group3&quot;, marker = list(color = &quot;darkgrey&quot;, opacity = 0.5, symbol = &quot;circle&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;daily standby: &quot;, sprintf(&quot;%.0f W&quot;, min), &quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.0f W&quot;, rminStandby), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~averageStandby, yend = ~averageStandby, name = &quot;Average Standby Total&quot;, legendgroup = &quot;group3&quot;, line = list(color = &quot;black&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;Average standby power: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;equals to daily energy: &quot;, sprintf(&quot;%.1f kWh&quot;, averageStandby*24/1000), &quot;&lt;br /&gt;Standby percent of total cons.: &quot;, sprintf(&quot;%.0f %%&quot;, shareStandby) ) ) %&gt;% add_annotations( x = maxX, y = averageStandby, text = paste0(sprintf(&quot;%.0f W&quot;, averageStandby), &quot; standby-losses on average&quot;), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = -60, ay = -20, font = list(color = &quot;black&quot;) ) %&gt;% layout( title = &quot;Electricity Household&quot;, xaxis = list( title = &quot;&quot; ), yaxis = list(title = &quot; Standby&lt;br&gt;(W)&quot;, range = c(minY, maxYStandby), titlefont = list(size = 14, color = &quot;darkgrey&quot;), legend = list(orientation = &#39;h&#39;)), legend = l ) # calculate ratio which is visual representative for comparison # ratio &lt;- 1/maxYUsage * maxYStandby * 24 / 1000 ratio &lt;- 0.3 fig &lt;- subplot(fig1, fig2, nrows = 2, shareX = TRUE, heights = c(1-ratio, ratio), titleY = TRUE) %&gt;% plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE, toImageButtonOptions = list( format = &quot;png&quot; ) ) fig 15.1.4 See also You probably noticed the line with the average consumption value. This gets calculated by the recommended values and formulas of the study Typischer Haushalt-Stromverbrauch - Schlussbericht by Nipkov, J. (2013) You can find the implementation in redutils function getTypEleConsHousehold() where various parameters can get adapted via function call arguments. "],["room-temperature-reduction.html", "15.2 Room Temperature Reduction", " 15.2 Room Temperature Reduction 15.2.1 Goal As part of an energy optimization, you lower the room temperatures in a room and would now like to show the reduction effect using the time series of the room temperature sensor. In the example below you make two optimizations at different dates. You want to create a time series plot with: the daily median, min and max value the overall median of each period the desired setpoint Figure 15.3: Room Temperature Reduction Plot 15.2.2 Data Basis Time series data from e.g. a temperature sensor with unaligned time intervals Figure 15.4: Raw Data Temperature for Room Temperature Reduction Plot 15.2.3 Solution Create a new script, copy/paste the following code and run it: library(dplyr) library(lubridate) library(dygraphs) library(xts) library(redutils) library(RColorBrewer) # Settings tempSetpoint = 22.0 startDate = &quot;2018-11-01&quot; endDate = &quot;2019-02-01&quot; optiDate1 = &quot;2018-12-17&quot; optiLabel1 = &quot;Optimization I&quot; optiDate2 = &quot;2019-01-03&quot; optiLabel2 = &quot;Optimization II&quot; optiDelayDays = 5 # read and print data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and remove empty cells df &lt;- df %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() # create column with day for later grouping df$time &lt;- parse_date_time(df$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$day &lt;- as.Date(cut(df$time, breaks = &quot;day&quot;)) df$day &lt;- as.Date(as.character(df$day,&quot;%Y-%m-%d&quot;)) # filter time range df &lt;- df %&gt;% filter(day &gt; startDate, day &lt; endDate) # calculate daily median, min and max of temperature df &lt;- df %&gt;% group_by(day) %&gt;% dplyr::mutate(minDay = min(as.numeric(FlatA_Temp)), medianDay = median(as.numeric(FlatA_Temp)), maxDay = max(as.numeric(FlatA_Temp)) ) %&gt;% ungroup() # shrink down to daily values and remove rows with empty values df &lt;- df %&gt;% select(day, medianDay, minDay, maxDay) %&gt;% unique() %&gt;% na.omit() # calculate medians for time ranges df &lt;- df %&gt;% dplyr::mutate(period = ifelse(day &gt;= startDate &amp; day &lt;= optiDate1, &quot;Baseline&quot;, ifelse((day &gt;= (as.Date(optiDate1) + optiDelayDays)) &amp; (day &lt;= optiDate2), &quot;Opti1&quot;, ifelse((day &gt;= (as.Date(optiDate2) + optiDelayDays)) &amp; (day &lt;= endDate), &quot;Opti2&quot;, NA) ))) df &lt;- df %&gt;% group_by(period) %&gt;% dplyr::mutate(medianPeriod = ifelse(is.na(period), NA, median(medianDay))) %&gt;% ungroup() %&gt;% select(-period) # create xts object for plotting plotdata &lt;- xts( x=df[,-1], order.by=df$day) # plot graph dygraph(plotdata, main = &quot;Room Temperature Reduction&quot;) %&gt;% dyAxis(&quot;x&quot;, drawGrid = FALSE) %&gt;% dySeries(c(&quot;minDay&quot;, &quot;medianDay&quot;, &quot;maxDay&quot;), label = &quot;Temperature&quot;) %&gt;% dySeries(c(&quot;medianPeriod&quot;), label = &quot;Median Period&quot;, strokePattern = &quot;dashed&quot;) %&gt;% dyOptions(colors = RColorBrewer::brewer.pal(3, &quot;Set2&quot;)) %&gt;% dyEvent(x = optiDate1, label = optiLabel1, labelLoc = &quot;bottom&quot;, color = &quot;slategray&quot;, strokePattern = &quot;dotted&quot;) %&gt;% dyEvent(x = optiDate2, label = optiLabel2, labelLoc = &quot;bottom&quot;, color = &quot;slategray&quot;, strokePattern = &quot;dotted&quot;) %&gt;% dyLimit(tempSetpoint, color = &quot;red&quot;, label = &quot;Target Setpoint&quot;) %&gt;% dyRangeSelector() %&gt;% dyLegend(show = &quot;always&quot;) 15.2.4 Discussion In this example we used the dygraph package to create the graph. This package is fast and allows to show a rangeslider on the bottom of the graph. The exact same graph but without a slider is as well possible with ggplot. Please note that the calculation of the periodic median after optimization I and II starts delayed because it takes time until the building has cooled down. "],["building-energy-signature.html", "15.3 Building Energy Signature", " 15.3 Building Energy Signature 15.3.1 Goal You want to create a scatter plot with: the daily mean outside temperature on the x-axis the daily energy consumption on the y-axis points colored according to season Figure 15.5: Building Energy Signature Plot 15.3.2 Data Basis Two separate csv files with time series data from the outside temperature and the energy data with unaligned time intervals: Figure 15.6: Outside Temperature Raw Data for Building Energy Signature Plot Figure 15.7: Energy Meter Raw Data for Building Energy Signature Plot 15.3.3 Solution After reading in the two time series the data has to get aggregated per day and then merged. Note that during the aggregation of the energy data you have to calculate the daily conspumption from the steadiliy increasing meter values as well. Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) library(redutils) library(lubridate) # load time series data and aggregate daily mean values dfOutsideTemp &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfOutsideTemp$time &lt;- parse_date_time(dfOutsideTemp$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) dfOutsideTemp$day &lt;- as.Date(cut(dfOutsideTemp$time, breaks = &quot;day&quot;)) dfOutsideTemp &lt;- dfOutsideTemp %&gt;% group_by(day) %&gt;% dplyr::mutate(tempMean = mean(centralOutsideTemp)) %&gt;% ungroup() dfOutsideTemp &lt;- dfOutsideTemp %&gt;% select(day, tempMean) %&gt;% unique() %&gt;% na.omit() dfHeatEnergy &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralHeating.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfHeatEnergy &lt;- dfHeatEnergy %&gt;% select(time, energyHeatingMeter) %&gt;% na.omit() dfHeatEnergy$time &lt;- parse_date_time(dfHeatEnergy$time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) dfHeatEnergy$day &lt;- as.Date(cut(dfHeatEnergy$time, breaks = &quot;day&quot;)) dfHeatEnergy &lt;- dfHeatEnergy %&gt;% group_by(day) %&gt;% dplyr::mutate(energyMax = max(energyHeatingMeter)) %&gt;% ungroup() dfHeatEnergy &lt;- dfHeatEnergy %&gt;% select(day, energyMax) %&gt;% unique() %&gt;% na.omit() dfHeatEnergy &lt;- dfHeatEnergy %&gt;% dplyr::mutate(energyCons = energyMax - lag(energyMax)) %&gt;% select(-energyMax) %&gt;% na.omit() # merge the data in a tidy format df &lt;- merge(dfOutsideTemp, dfHeatEnergy, by = &quot;day&quot;) # calculate season df &lt;- df %&gt;% dplyr::mutate(season = redutils::getSeason(df$day)) # static chart with ggplot plot &lt;- ggplot2::ggplot(df) + ggplot2::geom_point(aes(x = tempMean, y = energyCons, color = season, alpha = 0.1, text = paste(&quot;&lt;/br&gt;Date: &quot;, as.Date(df$day), &quot;&lt;/br&gt;Temp: &quot;, round(df$tempMean, digits = 1), &quot;\\u00B0C&quot;, &quot;&lt;/br&gt;Energy: &quot;, round(df$energyCons, digits = 0), &quot;kWh/d&quot;, &quot;&lt;/br&gt;Season: &quot;, df$season)) ) + scale_color_manual(values=c(&quot;#440154&quot;, &quot;#2db27d&quot;, &quot;#fde725&quot;, &quot;#365c8d&quot;)) + ggtitle(&quot;Building Energy Signature&quot;) + theme_minimal() + theme( legend.position=&quot;none&quot;, plot.title = element_text(hjust = 0.5) ) # interactive chart plotly::ggplotly(plot, tooltip = c(&quot;text&quot;)) %&gt;% layout(xaxis = list(title = &quot;Outside temperature (\\u00B0C)&quot;, range = c(min(-5,min(df$tempMean)), max(35,max(df$tempMean))), zeroline = F), yaxis = list(title = &quot;Daily energy consumption (kWh/d)&quot;, range = c(-5, max(df$energyCons) + 10)), showlegend = TRUE ) %&gt;% plotly::config(displayModeBar = FALSE, displaylogo = FALSE) 15.3.4 Discussion This visualization allows a quick detection of malfunctions and provides valuable information on the energy efficiency of the building. A constant indoor temperature is assumed It is also assumed that the outside temperature is the parameter with the greatest influence on heating energy consumption This method is suitable for buildings with stable internal heat loads and relatively low passive solar heat loads "],["building-energy-signature-proposed.html", "15.4 Building Energy Signature Proposed", " 15.4 Building Energy Signature Proposed 15.4.1 Goal Create a plot of a building energy signature as proposed in Development and validation of energy signature method, Eriksson et al, 2020: Figure 15.8: Building Energy Signature Plot PES 15.4.2 Data Basis Figure 15.9: Energy Meter Raw Data for Building Energy Signature Plot Figure 15.10: Energy Meter Raw Data for Building Energy Signature Plot Figure 15.11: Energy Meter Raw Data for Building Energy Signature Plot 15.4.3 Solution After reading in the two time series the data has to get aggregated per day and then merged. Note that during the aggregation of the energy data you have to calculate the daily conspumption from the steadiliy increasing meter values as well. Create a new script, copy/paste the following code and run it: library(plotly) library(plyr) library(lubridate) library(redutils) df.all &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/bldgEngySigProposedData.csv&quot;, stringsAsFactors=FALSE, sep =&quot;,&quot;) names(df.all)[1] &lt;- &quot;time&quot; names(df.all)[2] &lt;- &quot;TOa&quot; names(df.all)[3] &lt;- &quot;Energy&quot; names(df.all)[4] &lt;- &quot;TRoom&quot; df.all$time &lt;- as.POSIXct(df.all$time, format=&quot;%Y-%m-%dT%H:%M:%OSZ&quot;, tz=&quot;Europe/Zurich&quot;) df.all &lt;- df.all %&gt;% dplyr::mutate(season = getSeason(time), day = lubridate::date(time), month = lubridate::month(time), week = lubridate::week(time), hour = lubridate::hour(time), power = Energy ) %&gt;% na.omit() # Initial Balance Temperature Tb Tb &lt;- 12 # Initial difference delta &lt;- 1 while(abs(delta) &gt; 0.1){ # calculate standby power pStby # conditions # - TOa &gt; Tb df &lt;- df.all %&gt;% group_by(week) %&gt;% dplyr::mutate(keep = (mean(TOa, na.rm = TRUE) &gt; Tb), pStby = min(power, na.rm = TRUE)) %&gt;% filter(keep == TRUE) %&gt;% select(-Energy) pStby &lt;- mean(df$pStby, na.rm = TRUE) # calculate hotwater power pHw # conditions # - TOa &gt; Tb df &lt;- df.all %&gt;% group_by(week) %&gt;% dplyr::mutate(keep = (mean(TOa, na.rm = TRUE) &gt; Tb)) %&gt;% dplyr::mutate(pHw = mean(power, na.rm = TRUE)) %&gt;% filter(keep == TRUE) pHw &lt;- mean(df$pHw, na.rm = TRUE) - pStby # Assumption for internal heat gains pIhg &lt;- 3*90*9/1000/4.5 # 3 W/m^2, 90m^2/flat, 9 flats, COP WP 4.5, 24 hours per day # calculate internal heat generation pIhg # conditions # - Month is Jan, Feb and March # - TOa &lt; Tb df &lt;- df.all %&gt;% filter(month %in% c(1,2,3)) %&gt;% group_by(day) %&gt;% dplyr::mutate(keep = (max(TOa, na.rm = TRUE) &lt; Tb)) %&gt;% filter(keep == TRUE) %&gt;% dplyr::mutate(meanPower = mean(power, na.rm = TRUE)) %&gt;% dplyr::mutate(meanTOa = mean(TOa, na.rm = TRUE)) %&gt;% dplyr::mutate(meanTRoom = mean(TRoom, na.rm = TRUE)) %&gt;% select(day, meanPower, meanTOa, meanTRoom, week) %&gt;% unique() # calculate Building total heat loss coefficient QTot in kW/K df &lt;- df %&gt;% dplyr::mutate(QTot = (meanPower - pStby - pHw + pIhg)/(meanTRoom - meanTOa)) QTot &lt;- mean(df$QTot, na.rm = TRUE) result &lt;- NULL # Iterative determination of balance temperature Tb for(i in seq(10,30,0.1)){ df.i &lt;- df.all %&gt;% dplyr::mutate(tempDiff = i - TOa) %&gt;% filter(tempDiff &gt; 0) df.i &lt;- df.i %&gt;% dplyr::mutate(powerCalc = (QTot * tempDiff + pStby + pHw)) percDiff &lt;- 100/sum(df.all$power, na.rm = TRUE) * sum(df.i$powerCalc, na.rm = TRUE) result = rbind(result, data.frame(Tb = i, percDiff = percDiff, power = sum(df.all$power), powerCalc = sum(df.i$powerCalc))) } Tb.new &lt;- result[which(abs(result$percDiff-100) == min(abs(result$percDiff - 100), na.rm = TRUE)),1] delta &lt;- Tb - Tb.new Tb &lt;- Tb.new } # create plot df &lt;- df.all %&gt;% group_by(day) %&gt;% dplyr::mutate(TOaMean = mean(TOa, na.rm = TRUE)) %&gt;% dplyr::mutate(powerSum = mean(power, na.rm = TRUE)) %&gt;% select(day, TOaMean, powerSum, season) %&gt;% na.omit() %&gt;% unique() %&gt;% ungroup() names(df)[2] &lt;- &quot;TOa&quot; names(df)[3] &lt;- &quot;Power&quot; # df &lt;- df %&gt;% dplyr::mutate((EnergyHeat = TOa * -0.04955 + 4.5865) * Energy) # names(df)[5] &lt;- &quot;EnergyHeat&quot; df.fall &lt;- df %&gt;% filter(season==&quot;Fall&quot;) df.winter &lt;- df %&gt;% filter(season==&quot;Winter&quot;) df.spring &lt;- df %&gt;% filter(season==&quot;Spring&quot;) df.summer &lt;- df %&gt;% filter(season==&quot;Summer&quot;) # annotations a_Tb &lt;- list( x = Tb, y = pStby + pHw, text = paste0(&quot;Balance Temperature&lt;br&gt; Tb = &quot;, round(Tb, digits = 1), &quot; \\u00B0C&quot; ), showarrow = TRUE, arrowhead = 7, ax = 70, ay = -70 ) a_QTot &lt;- list( x = (Tb-min(df$TOa, na.rm = TRUE))/2+min(df$TOa, na.rm = TRUE), y = (Tb-min(df$TOa, na.rm = TRUE)) * QTot/2+pStby + pHw, text = paste0(&quot;Heat Loss Coefficient&lt;br&gt;QTot = &quot;, round(QTot, digits = 3), &quot; kW/K&quot;), showarrow = TRUE, arrowhead = 2, ax = 120, ay = -50 ) # Create plot p &lt;- plot_ly() p &lt;- p %&gt;% add_lines(x = c(min(df$TOa, Tb, na.rm = TRUE),max(df$TOa, na.rm = TRUE)), y = rep((pStby + pHw), 2), name = &quot;Base Load + Standby&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Base Load + Standby: &quot;, sprintf(&quot;%.3f kW&quot;, pStby + pHw) )) p &lt;- p %&gt;% add_lines(x = c(min(df$TOa, Tb, na.rm = TRUE), max(df$TOa, na.rm = TRUE)), y = rep(pStby, 2), name = &quot;Standby&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Standby: &quot;, sprintf(&quot;%.3f kW&quot;, pStby) )) p &lt;- p %&gt;% add_lines(x = c(min(df$TOa, na.rm = TRUE), Tb), y = c((Tb-min(df$TOa, na.rm = TRUE)) * QTot + pStby + pHw, pStby + pHw), name = &quot;Heating&quot;) p &lt;- p %&gt;% add_markers(data = df.spring, x = ~TOa, y = ~Power, marker = list(color = &quot;#2db27d&quot;, opacity = 0.3), name = &quot;Spring&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Outside Temp: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, TOa), &quot;&lt;br /&gt;Power: &quot;, sprintf(&quot;%.1f kW&quot;, Power), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, df.spring$season ) ) p &lt;- p %&gt;% add_markers(data = df.summer, x = ~TOa, y = ~Power, marker = list(color = &quot;#fde725&quot;, opacity = 0.3), name = &quot;Summer&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Outside Temp: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, TOa), &quot;&lt;br /&gt;Power: &quot;, sprintf(&quot;%.1f kW&quot;, Power), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, df.summer$season ) ) p &lt;- p %&gt;% add_markers(data = df.fall, x = ~TOa, y = ~Power, marker = list(color = &quot;#440154&quot;, opacity = 0.3), name = &quot;Fall&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Outside Temp: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, TOa), &quot;&lt;br /&gt;Power: &quot;, sprintf(&quot;%.1f kW&quot;, Power), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, df.fall$season ) ) p &lt;- p %&gt;% add_markers(data = df.winter, x = ~TOa, y = ~Power, marker = list(color = &quot;#365c8d&quot;, opacity = 0.3), name = &quot;Winter&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Outside Temp: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, TOa), &quot;&lt;br /&gt;Power: &quot;, sprintf(&quot;%.1f kW&quot;, Power), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, df.winter$season ) ) p &lt;- p %&gt;% layout( xaxis = list(title = &quot;Outside temperature (\\u00B0C)&quot;, range = c(min(-10,min(df.all$TOa)), max(35,max(df.all$TOa))), zeroline = F), yaxis = list(title = &quot;Power (kW)&quot;, range = c(min(df$Power, max(df$Power)))), showlegend = TRUE, legend = list(orientation = &quot;h&quot;, y = -0.2, x = 0), annotations = list(a_Tb,a_QTot) ) %&gt;% plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE) p 15.4.4 Discussion This is a new method, which calculates the balance Temperture, a heating loss coefficient in kW/K, a basic consumption (blue line) and a standby value (orange line) from 15min consumption data of an electric or heat meter in an iterative procedure using the outside and room temperature. "],["plotly-multiple-y-axis.html", "15.5 Plotly Multiple Y Axis", " 15.5 Plotly Multiple Y Axis 15.5.1 Goal You want to create a plot with more than one y axis: Figure 15.12: Plotly Polot with Multiple Y Axis 15.5.2 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(plyr) library(plotly) # read and print data data &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and humidity and remove empty cells data &lt;- data %&gt;% select(time, FlatA_Temp, FlatA_Hum) %&gt;% na.omit() colnames(data) &lt;- c(&quot;time&quot;, &quot;tempRaw&quot;, &quot;humidityRaw&quot;) # create plot # axis properties minyaxis1 &lt;- floor(min(14.0,min(data$temperature))) maxyaxis1 &lt;- ceiling(max(28.0,max(data$temperature))) minyaxis2 &lt;- 0.0 maxyaxis2 &lt;- 100.0 dateRange &lt;- c(min(data$time), max(data$time)) plotColors &lt;- c(&quot;darkgreen&quot;, &quot;orange&quot;) pAxisSpacer &lt;- 0.07 plot &lt;- plot_ly(data, x = ~time) %&gt;% add_lines(y = ~tempRaw, type=&quot;scatter&quot;, mode=&quot;lines&quot;, name=&#39;Temperatur&#39;, line = list(color = plotColors[1], width = 1) ) %&gt;% add_lines(y = ~humidityRaw, type=&quot;scatter&quot;, mode=&quot;lines&quot;, name=&#39;Humidity&#39;, yaxis=&#39;y2&#39;, line = list(color = plotColors[2], width = 1) ) %&gt;% layout( xaxis = list(title = &quot;Date &amp; Time&quot;, domain = c(pAxisSpacer*3, 1), type = &quot;date&quot;, range = dateRange, ticks=&#39;outside&#39;, zeroline=TRUE, showline = T), yaxis = list(title = &#39;Temperature&#39;, side = &quot;left&quot;, color = plotColors[1], range = c(minyaxis1,maxyaxis1), ticks=&#39;outside&#39;, dtick = 2, tick0 = minyaxis1, tickmode = &quot;linear&quot;, position = 0, anchor = &#39;free&#39;, zeroline = F, showline = T), yaxis2 = list(title = &#39;Humidity&#39;, side = &quot;left&quot;, color = plotColors[2], range = c(minyaxis2,maxyaxis2), ticks=&#39;outside&#39;, dtick = 10, tick0 = minyaxis2, tickmode = &quot;linear&quot;, position = pAxisSpacer, overlaying = &quot;y&quot;, anchor = &#39;free&#39;, zeroline=F, showline = T), legend = list(x=pAxisSpacer*3.5, y= 1), showlegend = T, title = list(text = &quot;Ploty plot with multiple y axis&quot;) ) plot "],["packages.html", "A Packages in R", " A Packages in R Many functions of R are not pre-installed and must be loaded manually. R packages are similar to libraries in C, Python etc. An R package bundles useful functions, help files and data sets. You can use these functions within your own R code once you load the package. The following chapters describe how to install, load, update and use packages. "],["installing-a-package.html", "A.1 Installing a Package", " A.1 Installing a Package The easiest way to install an R Package is to use the RStudio tab Packages: Figure A.1: Install packages via RStudio GUI Click on the Packages tab Click on Install next to Update Type the name of the package under Packages, in this case type ggplot2 Click Install This will search for the package ggplot specified on a server (the so-called CRAN website). If the package exists, it will be downloaded to a library folder on your computer. Here R can access the package in future R sessions without having to reinstall it. An other way is to use the install.packages function. Open R (if already opened please close all projects) and type the following at the command line: install.packages(&quot;ggplot2&quot;) If you want to install a package directly from github, the package devtools must be installed first: install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;hslu-ige-laes/redutils&quot;) "],["loading-a-package.html", "A.2 Loading a Package", " A.2 Loading a Package If you have installed a package, its functions are not yet available in your R project. To use an R package in your sript, you must load it with the following command: install.packages(&quot;ggplot2&quot;) "],["upgrading-packages.html", "A.3 Upgrading Packages", " A.3 Upgrading Packages R packages are often constantly updated on CRAN or GitHub, so you may want to update them once in a while with: update.packages(ask = FALSE) "]]
