[["index.html", "Energy Data Analysis with R Chapter 1 Introduction", " Energy Data Analysis with R Reto Marek 2020-11-25 Chapter 1 Introduction Preface This book gives you an overview of the statistical software R and its ability to analyze and visualize time series in the context of building energy and comfort. It is aimed at R beginners as well as exerienced R users and is strongly inspired by the R Graphics Cookbook and Engineering Data Analysis in R. The aim of this book is to provide additional specific recipes for energy and comfort related tasks and to make your entry into R smooth and easy. "],["content.html", "1.1 Content", " 1.1 Content The book is independently structured and a beginner gets information on how to install the program environment and gets a quick practical introduction. The examples in this book will show you how to complete certain specific tasks. Examples are shown so that you can understand the basic principle and reproduce the analysis or visualization with your own data. Simply copy the code into your R-script, replace the sample data files with your own and execute the code. This book was developed using Yihui Xies bookdown framework. The book is built using code that combines R code, data, and text to create a book for which R code and examples can be re-executed every time the book is re-built. The online book is hosted using GitHubs free GitHub Pages. All material for this book is available and can be explored at the books GitHub repository. "],["why-r-and-rstudio.html", "1.2 Why R and RStudio?", " 1.2 Why R and RStudio? In a study commissioned by the Swiss Federal Office of Energy, experts from the field were asked how and where they perform energy analyses and create visualizations. The result was that many people today either need Excel or use a building monitoring software to execute analysis and create visualizations. Excel users are pushing the program to its limits with the ever-increasing data sets. Also the interactive ability of the graphics there is limited. The change to an environment like R seems to be difficult for many. In the market there are numerous books which make the change to R for other disciplines easier. However, experts from the energy and building services engineering industry lack a corresponding work. The present book is intended to close this gap. The freely available programming language R and its graphical user interface RStudio offer many more possibilities for data analysis and data visualization. "],["other-useful-sources.html", "1.3 Other useful sources", " 1.3 Other useful sources A really good source is R for Data Science by Garrett Grolemund and Hadley Wickham. The entire book is freely available online through the same format of this book. There are a number of other useful books available on general R programming, including: R Graphics Cookbook Introduction to Data Science - Data Analysis and Prediction Algorithms with R Hands-On Programming with R Engineering Data Analysis in R "],["getting-started.html", "Chapter 2 Getting started ", " Chapter 2 Getting started "],["installation.html", "2.1 Install R and R Studio", " 2.1 Install R and R Studio Before we can start the first analysis, we have to install R and RStudio. This may seem laborious, but it is necessary and easier than it appears at first glance. R is a programming language used for statistical computing while RStudio provides a graphical user interface R may be used without RStudio, but RStudio may not be used without R Both, R and RStudio are free of charge and there are no licencse fees When you later make an analysis and visualizations, you only work in the graphical user interface RStudio 2.1.1 Download and Install R 2.1.1.1 Windows Open https://cran.r-project.org/bin/windows/base/ and press the link Download R Run the downloaded installer file and follow the installation wizard The wizard will install R into your Program Files folders and adds a shortcut in your Start menu. Note that you will need to have all necessary administration rights to install new software on your machine. 2.1.1.2 Mac OSX Open https://cran.r-project.org/bin/macosx/ and download the latest *.pkg file Run the downloaded installer file and follow the installation wizard The installer allows you to customize your installation. However the default values will be suitable for most users. 2.1.1.3 Linux R is part of many Linux distributions, therefore you should check with your Linux package management system if its already installed. The CRAN website provides files to build R from source on Debian, Redhat, SUSE, and Ubuntu systems under the link Download R for Linux Open https://cran.r-project.org/bin/linux/ and then follow the directory trail to the version of Linux you wish to install R on top of The exact installation procedure will vary depending on your Linux operating system. CRAN supports the process by grouping each set of source files with documentation or README files that explain how to install on your system. 2.1.2 Download and Install RStudio R Studio is a development environment for R. Open https://rstudio.com/products/rstudio/download/ and download RStudio Desktop Open Source Follow the on-screen instructions Once you have installed R Studio, you can run it like any other application by clicking the program icon "],["install-required-packages.html", "2.2 Install required packages", " 2.2 Install required packages Appendix A gives you an introduction to what a package is and how to install it. Below are the packages used in this book and it is recommended to install them now. Open RStudio just as you would any program, by clicking on its icon Copy the following code and paste it into your console (on the bottom left, right of the symbol &gt;): install.packages(&quot;devtools&quot;, &quot;tidyverse&quot;, &quot;plotly&quot;, &quot;lubridate&quot;, &quot;r2d3&quot;, &quot;checkmate&quot;) install_github(&quot;hslu-ige-laes/redutils&quot;) Press Enter or Return The installation of the packages is now in progress and this may take a while, please be patient. In the meantime you can read in appendix A what packages are in general and how they can be installed and later loaded into scripts. "],["create-an-r-script.html", "2.3 Create an R Script", " 2.3 Create an R Script Finally, you have installed R and RStudio with the first set of packages on your computer. Lets create the first visualization. - Open RStudio just as you would any program, by clicking on its icon - Go to the menu on the top left and click to File / New File / R Script - Copy the following code and paste it into your script: library(graphics) plot(co2, ylab = &quot;CO2 (ppm)&quot;, las = 1) title(main = &quot;Mauna Loa Atmospheric CO2 Concentration&quot;) select all by pressing Ctrl + A Thren run the code by pressing the Run Button or Ctrl + Enter You should now get your first visualization: As you probably noticed, we did not load any data. The basic installation of R and some packages come with test data. So that is an easy way to test something. The R Dataset Package provides some preinstalled datasets, including the used Mauna Loa Atmospheric CO2 Concentration dataset. "],["whats-next.html", "2.4 Whats next?", " 2.4 Whats next? Now hopefully, everything has worked fine so far with the installation and your first visualization. Congratulations! You have now a running R environment and we can start with more interesting stuff. The following chapters will give you an overview "],["r-basics.html", "Chapter 3 R Basics ", " Chapter 3 R Basics "],["loading-data.html", "3.1 Loading Data", " 3.1 Loading Data 3.1.1 Csv File df &lt;- read.csv(&quot;datafile.csv&quot;) df &lt;- read.csv(&quot;datafile.csv&quot;, header=FALSE, stringsAsFactors=FALSE) df &lt;- read.csv(&quot;https://github.com/retomarek/r/raw/master/datasets/buildingMonitoringTestDataSet.csv&quot;, stringsAsFactors=FALSE, sep =&quot;,&quot;, na.strings = c(&quot;&quot;, &quot;NA&quot;)) Attention: By default, strings in the data are treated as factors. read.csv() is a convenience wrapper function around read.table(). If you need more control over the input, see ?read.table 3.1.2 Excel File # Only need to install once install.packages(&quot;xlsx&quot;) library(xslx) df &lt;- read.xlsx(&quot;datafile.xlsx&quot;, 1) df &lt;- read.xlsx(&quot;datafile.xls&quot;, sheetIndex=2) df &lt;- read.xlsx(&quot;datafile.xls&quot;, sheetName=&quot;Revenues&quot;) For reading older Excel files in the .xls format, the gdata package has the function read.xls(): # Only need to install once install.packages(&quot;gdata&quot;) library(gdata) # Read first sheet df &lt;- read.xls(&quot;datafile.xls&quot;) df &lt;- read.xls(&quot;datafile.xls&quot;, sheet=2) Both the xlsx and gdata packages require other software to be installed on your computer. For xlsx, you need to install Java on your machine. For gdata, you need Perl, which comes as standard on Linux and Mac OS X, but not Windows. On Windows, youll need ActiveState Perl. The Community Edition can be obtained for free. "],["data-wrangling.html", "Chapter 4 Data Wrangling ", " Chapter 4 Data Wrangling "],["add-metadata-for-later-filtering.html", "4.1 Add Metadata for later filtering", " 4.1 Add Metadata for later filtering Firstly we have to load a dataset into a dataframe: # load data set df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) 4.1.1 Year, Month, Day, Day of Week To group, filter and aggregate data we need to have a the date splitted up in day, month and year separately: library(dplyr) library(lubridate) df$time &lt;- parse_date_time(df$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$year &lt;- as.Date(cut(df$time, breaks = &quot;year&quot;)) df$month &lt;- as.Date(cut(df$time, breaks = &quot;month&quot;)) df$day &lt;- as.Date(cut(df$time, breaks = &quot;day&quot;)) df$weekday &lt;- wday(df$time, label = TRUE, locale = &quot;English&quot;, abbr = TRUE, week_start = getOption(&quot;lubridate.week.start&quot;, 1)) This code first parses the timestamp with a specific timezone. Then three columns are added. Please note that the month also contains the year and a day. This is useful for a later step where you can group the series afterwards. head(df,2) ## time centralOutsideTemp ## 1 2018-03-21 11:00:00 5.2 ## 2 2018-03-21 12:00:00 6.7 tail(df,2) ## time centralOutsideTemp ## 21864 2020-09-17 10:00:00 26.65 ## 21865 2020-09-17 11:00:00 28.10 4.1.2 Season of Year For some analyses it is useful to color single points of a scatterplot according to the season. For this we need to have the season in a separate column: library(redutils) # get season from a date getSeason(as.Date(&quot;2019-04-01&quot;)) ## [1] &quot;Spring&quot; If you want to change the language, you can give the function dedicated names for the season: getSeason(as.Date(&quot;2019-04-01&quot;), seasonlab = c(&quot;Winter&quot;,&quot;Frühling&quot;,&quot;Sommer&quot;,&quot;Herbst&quot;)) ## [1] &quot;Frühling&quot; To apply this function to a whole dataframe we can use the dplyr mutate function. The code below creates a new column named season: df &lt;- dplyr::mutate(df, season = getSeason(df$time)) head(df,1) ## time centralOutsideTemp season ## 1 2018-03-21 11:00:00 5.2 Spring tail(df,1) ## time centralOutsideTemp season ## 21865 2020-09-17 11:00:00 28.1 Fall "],["data-frames.html", "4.2 Data Frames", " 4.2 Data Frames Firstly we have to load a dataset into a dataframe: # load data set df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) 4.2.1 Change Row Names # Print the header and the first line head(df, 1) ## time FlatA_Hum FlatA_Temp FlatB_Hum FlatB_Temp FlatC_Hum ## 1 2018-10-03 00:00:00 53 24.43 38.8 22.4 44 ## FlatC_Temp FlatD_Hum FlatD_Temp ## 1 24.5 49 24.43 # rename columns and print the header and the first line names(df) &lt;- c(&quot;timestamp&quot;,&quot;Hum_A&quot;,&quot;Temp_A&quot;,&quot;Hum_B&quot;,&quot;Temp_B&quot;,&quot;Hum_C&quot;,&quot;Temp_C&quot;,&quot;Hum_D&quot;, &quot;Temp_D&quot;) head(df, 1) ## timestamp Hum_A Temp_A Hum_B Temp_B Hum_C Temp_C Hum_D Temp_D ## 1 2018-10-03 00:00:00 53 24.43 38.8 22.4 44 24.5 49 24.43 4.2.2 Wide to Long # create a copy of the dataframe and print the header and the first five line head(df, 5) ## timestamp Hum_A Temp_A Hum_B Temp_B Hum_C Temp_C Hum_D Temp_D ## 1 2018-10-03 00:00:00 53.0 24.43 38.8 22.40 44.0 24.5 49.0 24.43 ## 2 2018-10-03 01:00:00 53.0 24.40 38.8 22.40 44.0 24.5 49.0 24.40 ## 3 2018-10-03 02:00:00 53.0 24.40 39.3 22.40 44.7 24.5 48.3 24.38 ## 4 2018-10-03 03:00:00 53.0 24.40 40.3 22.40 45.0 24.5 48.0 24.33 ## 5 2018-10-03 04:00:00 53.3 24.40 41.0 22.37 45.2 24.5 47.7 24.30 # convert wide to long format df.long &lt;- as.data.frame(tidyr::pivot_longer(df, cols = -timestamp, names_to = &quot;sensor&quot;, values_to = &quot;value&quot;, values_drop_na = TRUE) ) # long format head(df.long, 16) ## timestamp sensor value ## 1 2018-10-03 00:00:00 Hum_A 53.00 ## 2 2018-10-03 00:00:00 Temp_A 24.43 ## 3 2018-10-03 00:00:00 Hum_B 38.80 ## 4 2018-10-03 00:00:00 Temp_B 22.40 ## 5 2018-10-03 00:00:00 Hum_C 44.00 ## 6 2018-10-03 00:00:00 Temp_C 24.50 ## 7 2018-10-03 00:00:00 Hum_D 49.00 ## 8 2018-10-03 00:00:00 Temp_D 24.43 ## 9 2018-10-03 01:00:00 Hum_A 53.00 ## 10 2018-10-03 01:00:00 Temp_A 24.40 ## 11 2018-10-03 01:00:00 Hum_B 38.80 ## 12 2018-10-03 01:00:00 Temp_B 22.40 ## 13 2018-10-03 01:00:00 Hum_C 44.00 ## 14 2018-10-03 01:00:00 Temp_C 24.50 ## 15 2018-10-03 01:00:00 Hum_D 49.00 ## 16 2018-10-03 01:00:00 Temp_D 24.40 4.2.3 Long to Wide # long format head(df.long) ## timestamp sensor value ## 1 2018-10-03 00:00:00 Hum_A 53.00 ## 2 2018-10-03 00:00:00 Temp_A 24.43 ## 3 2018-10-03 00:00:00 Hum_B 38.80 ## 4 2018-10-03 00:00:00 Temp_B 22.40 ## 5 2018-10-03 00:00:00 Hum_C 44.00 ## 6 2018-10-03 00:00:00 Temp_C 24.50 # convert long table into wide table df.wide &lt;- as.data.frame(tidyr::pivot_wider(df.long, names_from = &quot;sensor&quot;, values_from = &quot;value&quot;) ) # wide format head(df.wide) ## timestamp Hum_A Temp_A Hum_B Temp_B Hum_C Temp_C Hum_D Temp_D ## 1 2018-10-03 00:00:00 53.0 24.43 38.8 22.40 44.0 24.50 49.0 24.43 ## 2 2018-10-03 01:00:00 53.0 24.40 38.8 22.40 44.0 24.50 49.0 24.40 ## 3 2018-10-03 02:00:00 53.0 24.40 39.3 22.40 44.7 24.50 48.3 24.38 ## 4 2018-10-03 03:00:00 53.0 24.40 40.3 22.40 45.0 24.50 48.0 24.33 ## 5 2018-10-03 04:00:00 53.3 24.40 41.0 22.37 45.2 24.50 47.7 24.30 ## 6 2018-10-03 05:00:00 53.7 24.40 41.2 22.30 47.2 24.57 47.2 24.30 4.2.4 Merge two Dataframes library(dplyr) library(lubridate) # read file one and parse dates dfOutsideTemp &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfOutsideTemp$time &lt;- parse_date_time(dfOutsideTemp$time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # read file two and parse dates dfFlatTempHum &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfFlatTempHum$time &lt;- parse_date_time(dfFlatTempHum$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # merge the two files into a new data frame and keep only rows where all values are available df &lt;- merge(dfOutsideTemp, dfFlatTempHum, by = &quot;time&quot;) %&gt;% na.omit() "],["examples.html", "4.3 Examples", " 4.3 Examples 4.3.1 Import csv file from GWF Relay W60 M-Bus Logger Some data loggers have a cryptic data format which requires some data wrangling ahead before we can use the time series efficiently. Following an example of a M-Bus data loggger. library(tidyr) # load csv file df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater_GWF_RelayW60Logger.csv&quot;, stringsAsFactors=FALSE, sep =&quot;,&quot;) head(df,23) ## Datum Zeit Adr ID.Nr. HST Nr. Wert Einheit ## 1 01.01.10 00:00 1 1 GWF 1 729 kWh ## 2 01.01.10 00:00 1 1 GWF 2 80.92 m^3 ## 3 01.01.10 00:00 1 1 GWF 3 80.75 m^3 ## 4 01.01.10 00:00 1 1 GWF 4 26 °C ## 5 01.01.10 00:00 1 1 GWF 5 25 °C ## 6 01.01.10 00:00 1 1 GWF 6 1.3 K ## 7 01.01.10 00:00 1 1 GWF 7 375 hours ## 8 01.01.10 00:00 1 1 GWF 8 375 hours ## 9 01.01.10 00:00 1 1 GWF 9 0 l/h ## 10 01.01.10 00:00 1 1 GWF 10 0 kW ## 11 01.01.10 00:00 1 1 GWF 11 31.12.09 23:58 Win V ## 12 01.01.10 00:00 1 1 GWF 12 87 HCA ## 13 01.01.10 00:00 1 1 GWF 13 0 HCA ## 14 01.01.10 00:00 1 1 GWF 14 0 kWh ## 15 01.01.10 00:00 1 1 GWF 15 0 m^3 ## 16 01.01.10 00:00 1 1 GWF 16 0 m^3 ## 17 01.01.10 00:00 1 1 GWF 17 0 HCA ## 18 01.01.10 00:00 1 1 GWF 18 0 HCA ## 19 01.01.10 00:00 1 1 GWF 19 00.00.00 ## 20 01.01.10 00:00 1 1 GWF 20 $00 ## 21 01.01.10 00:00 2 4 GWF 1 751 kWh ## 22 01.01.10 00:00 2 4 GWF 2 71.97 m^3 ## 23 01.01.10 00:00 2 4 GWF 3 71.9 m^3 ## Beschreibung Art Modul SP.Nr. Tarif ## 1 energy instant. 0 0 0 ## 2 volume instant. 0 0 0 ## 3 volume instant. 1 0 0 ## 4 flow temperature instant. 0 0 0 ## 5 return temperature instant. 0 0 0 ## 6 temperature difference instant. 0 0 0 ## 7 on time instant. 0 0 0 ## 8 operating time instant. 0 0 0 ## 9 volume flow instant. 0 0 0 ## 10 power instant. 0 0 0 ## 11 time point instant. 0 0 0 ## 12 HCA-Unit instant. 1 0 0 ## 13 HCA-Unit instant. 2 0 0 ## 14 energy instant. 0 1 0 ## 15 volume instant. 0 1 0 ## 16 volume instant. 1 1 0 ## 17 HCA-Unit instant. 1 1 0 ## 18 HCA-Unit instant. 2 1 0 ## 19 time point instant. 0 1 0 ## 20 M-Bus state NA NA NA ## 21 energy instant. 0 0 0 ## 22 volume instant. 0 0 0 ## 23 volume instant. 1 0 0 Please note * The Date and Time are in separate columns * The HCA-Unit value has a factor of 10, so the above HCA-value of 87 are in 10 liters Units and result in 87 * 10 = 870 liter * In the example Adr is the identification of the flat We are only interested in Nr. 1 heating energy of the flat and Nr. 12 the impulse count of the additional meter which is the hot water of the flat. Following the required steps to parse the data and bring them in a format we can later work with: # create timestamp out of column &quot;Date&quot; and &quot;Time&quot; df &lt;- df %&gt;% mutate(timestamp = paste0(df$Datum, &quot; &quot;, df$Zeit)) df$timestamp &lt;- parse_date_time(df$timestamp, order = &quot;d.m.y H:M&quot;, tz = &quot;Europe/Zurich&quot;) # select columns and rearrange df &lt;- df %&gt;% select(timestamp, Adr, Nr., Wert, Einheit) # filter out Adr. of interest df &lt;- df %&gt;% filter(Nr. %in% c(1,12)) # rename columns df &lt;- df %&gt;% mutate(Nr. = ifelse(Nr. == 1, paste0(&quot;Adr&quot;,sprintf(&quot;%02.0f&quot;, Adr), &quot;_energyHeat&quot;), ifelse(Nr. == 12, paste0(&quot;Adr&quot;,sprintf(&quot;%02.0f&quot;, Adr), &quot;_hotWater&quot;), Nr.))) # convert value to numeric df$Wert &lt;- as.numeric(df$Wert) # multiply HCA-values by factor 10 to get liters and divide by 1000 to get m3 df &lt;- df %&gt;% mutate(Wert = ifelse((Einheit == &quot;HCA&quot;), Wert * 10/1000, Wert)) df &lt;- df %&gt;% select(-Einheit, -Adr) # convert long table into wide table df.wide &lt;- as.data.frame(pivot_wider(df, names_from = &quot;Nr.&quot;, values_from = Wert, names_sep = &quot;_&quot;) ) This is the result: head(df.wide) ## timestamp Adr01_energyHeat Adr01_hotWater Adr02_energyHeat Adr02_hotWater ## 1 2010-01-01 729 0.87 751 1.16 ## 2 2010-02-01 1850 2.18 2276 7.55 ## 3 2010-03-01 2806 5.84 2826 12.94 ## 4 2010-04-01 3615 9.92 3354 18.51 ## 5 2010-05-01 4150 13.38 3613 24.81 ## 6 2010-06-01 4669 17.50 3640 29.72 ## Adr04_energyHeat Adr04_hotWater Adr03_energyHeat Adr03_hotWater ## 1 972 1.56 799 0.07 ## 2 2526 8.14 3103 1.32 ## 3 3690 14.83 4786 3.73 ## 4 4700 20.82 6151 6.05 ## 5 5341 27.06 6900 7.74 ## 6 5802 31.61 7702 9.49 Finally saving the csv file: write.csv2(df.wide, file = &quot;flatHeatAndHotWater.csv&quot;, row.names = FALSE) "],["explorative-data-analysis.html", "Chapter 5 Explorative Data Analysis ", " Chapter 5 Explorative Data Analysis "],["get-overview.html", "5.1 Get overview", " 5.1 Get overview Get an overview of the whole data set and specific series of it 5.1.1 Load data Load test data set in a data frame (e.g. from a csv-file) df &lt;- read.csv(&quot;https://github.com/retomarek/r/raw/master/datasets/buildingMonitoringTestDataSet.csv&quot;, stringsAsFactors=FALSE, sep =&quot;,&quot; ) 5.1.2 Names show the column headers of the data frame names(df) ## [1] &quot;time&quot; &quot;WthStnPress&quot; &quot;WthStnHum&quot; ## [4] &quot;WthStnRain&quot; &quot;WthStnSolRad&quot; &quot;WthStnTemp&quot; ## [7] &quot;WthStnWindDir&quot; &quot;WthStnWindSpd&quot; &quot;BldgEnergyHotwater&quot; ## [10] &quot;BldgEnergyHeating&quot; &quot;FlatHum&quot; &quot;FlatTemp&quot; ## [13] &quot;FlatVolFlowColdwater&quot; &quot;FlatVolFlowHotwater&quot; 5.1.3 Structure show the structure of the data frame str(df) ## &#39;data.frame&#39;: 16394 obs. of 14 variables: ## $ time : chr &quot;2018-09-30T22:00:00.000Z&quot; &quot;2018-09-30T23:00:00.000Z&quot; &quot;2018-10-01T00:00:00.000Z&quot; &quot;2018-10-01T01:00:00.000Z&quot; ... ## $ WthStnPress : num 1012 1012 1011 1011 1011 ... ## $ WthStnHum : num 87 87.5 87.5 86.5 88 89 86.5 81 78 80.5 ... ## $ WthStnRain : num 0.8 1.1 0.5 0.5 0.6 0.1 0.2 0 0 0 ... ## $ WthStnSolRad : num 0 0 0 0 0 0 0 0 3 24.5 ... ## $ WthStnTemp : num 12.8 12.4 11.9 11.9 11.6 ... ## $ WthStnWindDir : num 157.5 11.2 146.2 157.5 146.2 ... ## $ WthStnWindSpd : num 3.2 1.6 2.4 0.8 2.4 0.8 0.8 3.2 4 3.2 ... ## $ BldgEnergyHotwater : num 0 19 0 0 0 ... ## $ BldgEnergyHeating : num 0 0 0 0 0 0 0 0 0 0 ... ## $ FlatHum : num NA NA NA NA NA NA NA NA NA NA ... ## $ FlatTemp : num NA NA NA NA NA NA NA NA NA NA ... ## $ FlatVolFlowColdwater: num 0.006 0 0 0 0.006 ... ## $ FlatVolFlowHotwater : num 0 0 0 0 0 ... 5.1.4 Head/Tail The head and tail functions are generic, so they will work whether your data is stored in a simple data frane, a zoo object, or an xts object. head(df) ## time WthStnPress WthStnHum WthStnRain WthStnSolRad ## 1 2018-09-30T22:00:00.000Z 1012.30 87.0 0.8 0 ## 2 2018-09-30T23:00:00.000Z 1011.90 87.5 1.1 0 ## 3 2018-10-01T00:00:00.000Z 1011.45 87.5 0.5 0 ## 4 2018-10-01T01:00:00.000Z 1010.90 86.5 0.5 0 ## 5 2018-10-01T02:00:00.000Z 1010.55 88.0 0.6 0 ## 6 2018-10-01T03:00:00.000Z 1010.20 89.0 0.1 0 ## WthStnTemp WthStnWindDir WthStnWindSpd BldgEnergyHotwater BldgEnergyHeating ## 1 12.80 157.50 3.2 0 0 ## 2 12.35 11.25 1.6 19 0 ## 3 11.90 146.25 2.4 0 0 ## 4 11.90 157.50 0.8 0 0 ## 5 11.60 146.25 2.4 0 0 ## 6 11.75 22.50 0.8 0 0 ## FlatHum FlatTemp FlatVolFlowColdwater FlatVolFlowHotwater ## 1 NA NA 0.006 0 ## 2 NA NA 0.000 0 ## 3 NA NA 0.000 0 ## 4 NA NA 0.000 0 ## 5 NA NA 0.006 0 ## 6 NA NA 0.000 0 tail(df) ## time WthStnPress WthStnHum WthStnRain WthStnSolRad ## 16389 2020-08-13T18:00:00.000Z 1011.650 74.75 2.19964 9 ## 16390 2020-08-13T19:00:00.000Z 1012.000 79.00 2.19964 0 ## 16391 2020-08-13T20:00:00.000Z 1011.950 78.25 2.19964 0 ## 16392 2020-08-13T21:00:00.000Z 1012.025 76.50 2.19964 0 ## 16393 2020-08-13T22:00:00.000Z 1012.250 73.00 0.00000 0 ## 16394 2020-08-13T23:00:00.000Z NA NA NA NA ## WthStnTemp WthStnWindDir WthStnWindSpd BldgEnergyHotwater ## 16389 22.000 162.00 0.000000 NA ## 16390 20.175 124.25 1.609340 NA ## 16391 19.350 125.00 0.402335 NA ## 16392 19.900 93.00 1.609340 NA ## 16393 20.625 116.25 2.414010 NA ## 16394 NA NA NA NA ## BldgEnergyHeating FlatHum FlatTemp FlatVolFlowColdwater ## 16389 NA NA NA NA ## 16390 NA NA NA NA ## 16391 NA NA NA NA ## 16392 NA NA NA NA ## 16393 NA NA NA NA ## 16394 NA NA NA NA ## FlatVolFlowHotwater ## 16389 NA ## 16390 NA ## 16391 NA ## 16392 NA ## 16393 NA ## 16394 NA 5.1.5 Five number summary reveals details of a specific series summary(df$WthStnTemp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## -5.25 5.50 11.25 11.99 17.35 40.30 12 "],["basic-plots.html", "5.2 Basic plots", " 5.2 Basic plots 5.2.1 Scatterplot 5.2.1.1 plot() # load data set df &lt;- read.csv(&quot;https://github.com/retomarek/r/raw/master/datasets/buildingMonitoringTestDataSet.csv&quot;, stringsAsFactors=FALSE, sep =&quot;,&quot;) # crate simple scatterplot plot(df$WthStnTemp, df$BldgEnergyHeating) "],["data-visualizations.html", "Chapter 6 Data Visualizations", " Chapter 6 Data Visualizations tbd "],["room-temperature-reduction.html", "6.1 Room Temperature Reduction", " 6.1 Room Temperature Reduction 6.1.1 Task As part of an energy optimization, you lower the room temperatures in a room and would now like to show the reduction effect using the time series of the room temperature sensor. In the example below you make two optimizations at different dates. You want to create a time series plot with the daily median, min and max value the overall median of each period the desired setpoint 6.1.2 Basis Time series data from e.g. a temperature sensor with unaligned time intervals 6.1.3 Solution library(dplyr) library(lubridate) library(dygraphs) library(xts) library(redutils) library(RColorBrewer) # Settings tempSetpoint = 22.0 startDate = &quot;2018-11-01&quot; endDate = &quot;2019-02-01&quot; optiDate1 = &quot;2018-12-17&quot; optiLabel1 = &quot;Optimization I&quot; optiDate2 = &quot;2019-01-03&quot; optiLabel2 = &quot;Optimization II&quot; optiDelayDays = 5 # read and print data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and remove empty cells df &lt;- df %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() # create column with day for later grouping df$time &lt;- parse_date_time(df$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$day &lt;- as.Date(cut(df$time, breaks = &quot;day&quot;)) df$day &lt;- as.Date(as.character(df$day,&quot;%Y-%m-%d&quot;)) # filter time range df &lt;- df %&gt;% filter(day &gt; startDate, day &lt; endDate) # calculate daily median, min and max of temperature df &lt;- df %&gt;% group_by(day) %&gt;% mutate(minDay = min(as.numeric(FlatA_Temp)), medianDay = median(as.numeric(FlatA_Temp)), maxDay = max(as.numeric(FlatA_Temp)) ) %&gt;% ungroup() # shrink down to daily values and remove rows with empty values df &lt;- df %&gt;% select(day, medianDay, minDay, maxDay) %&gt;% unique() %&gt;% na.omit() # calculate medians for time ranges df &lt;- df %&gt;% mutate(period = ifelse(day &gt;= startDate &amp; day &lt;= optiDate1, &quot;Baseline&quot;, ifelse((day &gt;= (as.Date(optiDate1) + optiDelayDays)) &amp; (day &lt;= optiDate2), &quot;Opti1&quot;, ifelse((day &gt;= (as.Date(optiDate2) + optiDelayDays)) &amp; (day &lt;= endDate), &quot;Opti2&quot;, NA) ))) df &lt;- df %&gt;% group_by(period) %&gt;% mutate(medianPeriod = ifelse(is.na(period), NA, median(medianDay))) %&gt;% ungroup() %&gt;% select(-period) # create xts object for plotting plotdata &lt;- xts( x=df[,-1], order.by=df$day) # plot graph dygraph(plotdata, main = &quot;Room Temperature Reduction&quot;) %&gt;% dyAxis(&quot;x&quot;, drawGrid = FALSE) %&gt;% dySeries(c(&quot;minDay&quot;, &quot;medianDay&quot;, &quot;maxDay&quot;), label = &quot;Temperature&quot;) %&gt;% dySeries(c(&quot;medianPeriod&quot;), label = &quot;Median Period&quot;, strokePattern = &quot;dashed&quot;) %&gt;% dyOptions(colors = RColorBrewer::brewer.pal(3, &quot;Set2&quot;)) %&gt;% dyEvent(x = optiDate1, label = optiLabel1, labelLoc = &quot;bottom&quot;, color = &quot;slategray&quot;, strokePattern = &quot;dotted&quot;) %&gt;% dyEvent(x = optiDate2, label = optiLabel2, labelLoc = &quot;bottom&quot;, color = &quot;slategray&quot;, strokePattern = &quot;dotted&quot;) %&gt;% dyLimit(tempSetpoint, color = &quot;red&quot;, label = &quot;Target Setpoint&quot;) %&gt;% dyRangeSelector() %&gt;% dyLegend(show = &quot;always&quot;) 6.1.4 Discussion In this example we used the dygraph package to create the graph. This package is fast and allows to show a rangeslider on the bottom of the graph. The exact same graph but without a slider is as well possible with ggplot. Please note that the calculation of the periodic median after optimization I and II starts delayed because it takes time until the building has cooled down. "],["seasonal-plot-xy.html", "6.2 Seasonal Plot - x/y", " 6.2 Seasonal Plot - x/y 6.2.1 Task Plot a seasonal plot as described in Hyndman and Athanasopoulos (2014, chapter 2). This is like a time plot except that the data are plotted against the seasons in separate years. Something like a time plot except that the data from each month are overlapped. Enables the underlying seasonal pattern to be seen more clearly, and also allows any substantial departures from the seasonal pattern to be easily identified. Figure 6.1: Seasonal Plot x/y per Month over 10 Years 6.2.2 Basis 6.2.3 Solution library(forecast) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) library(viridis) library(lubridate) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% mutate(value = lead(meterValue) - meterValue) # remove counter value column df &lt;- df %&gt;% select(-meterValue) # value correction (outlier because of commissioning) df[1,2] &lt;- 600 # create time series object for ggseanplot function df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 12, start = min(year(df$timestamp))) # create x/y plot numYears = length(unique(year(df$timestamp))) plot &lt;- ggseasonplot(df.ts, col = viridis(numYears), main = &quot;Seasonal Plot x/y per Month over 10 years&quot;, ylab = &quot;Energy Consumption (kWh/month)&quot; ) # change theme (optional) plot &lt;- plot + ggthemes::theme_economist() # make plot interactive (optional) plotly &lt;- plotly::ggplotly(plot) # show plot plotly # save static plot as png ggsave(&quot;images/plotSeasonalXY.png&quot;, plot) # save interactive plot as html library(htmlwidgets) htmlwidgets::saveWidget(plotly, &quot;plotlySeasonalXY.html&quot;) 6.2.4 Discussion "],["seasonal-plot-monthplot.html", "6.3 Seasonal Plot - Monthplot", " 6.3 Seasonal Plot - Monthplot 6.3.1 Task Figure 6.2: Seasonal Plot x/y per Month over 10 Years 6.3.2 Basis 6.3.3 Solution library(forecast) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) library(viridis) library(lubridate) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr01_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% mutate(value = lead(meterValue) - meterValue) # remove counter value column df &lt;- df %&gt;% select(-meterValue) # value correction (outlier because of commissioning) df[1,2] &lt;- 600 # create time series object for ggmonthplot function df.ts &lt;- ts(df[-1], frequency = 12, start = min(year(df$timestamp))) # create x/y plot numYears = length(unique(year(df$timestamp))) plot &lt;- ggmonthplot(df.ts, col = viridis(numYears), main = &quot;Seasonal Month-Plot over 10 years\\n&quot;, ylab = &quot;Energy Consumption (kWh/month)\\n&quot;, xlab = &quot;Month\\n &quot; ) # change theme (optional) plot &lt;- plot + ggthemes::theme_economist() # make plot interactive (optional) plotly &lt;- plotly::ggplotly(plot) # show plot plotly # save static plot as png ggsave(&quot;images/plotSeasonalMonth.png&quot;, plot) # save interactive plot as html library(htmlwidgets) htmlwidgets::saveWidget(plotly, &quot;plotlySeasonalMonth.html&quot;) 6.3.4 Discussion "],["seasonal-plot-polar.html", "6.4 Seasonal Plot - Polar", " 6.4 Seasonal Plot - Polar 6.4.1 Task Plot a seasonal polar plot as described in Hyndman and Athanasopoulos (2014, chapter 2). This is like a time plot except that the data are plotted against the seasons in separate years. Figure 6.3: Seasonal Plot Polar per Month over 10 Years 6.4.2 Basis 6.4.3 Solution library(forecast) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) library(viridis) library(lubridate) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% mutate(value = lead(meterValue) - meterValue) # remove counter value column df &lt;- df %&gt;% select(-meterValue) # value correction (outlier because of commissioning) df[1,2] &lt;- 600 df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 12, start = min(year(df$timestamp))) # create polar plot numYears = length(unique(year(df$timestamp))) plot &lt;- ggseasonplot(df.ts, col = viridis(numYears), main = &quot;Seasonal Plot Polar per Month over 10 Years&quot;, ylab = &quot;Energy Consumption (kWh/month)&quot;, polar = TRUE ) # show plot (interactive version with plotly not possible) plot # save static plot as png ggsave(&quot;images/plotSeasonalPolar.png&quot;, plot) 6.4.4 Discussion "],["seasonal-plot-xy-beforeafter.html", "6.5 Seasonal Plot - x/y Before/After", " 6.5 Seasonal Plot - x/y Before/After 6.5.1 Task Figure 6.4: Seasonal Plot x/y Before/After 6.5.2 Basis 6.5.3 Solution library(redutils) library(dplyr) library(plotly) library(htmlwidgets) library(ggthemes) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% mutate(value = lead(meterValue) - meterValue) # remove counter value column df &lt;- df %&gt;% select(-meterValue) # create plot plot &lt;- plotSeasonalXYBeforeAfter(df, dateOptimization = &quot;2017-09-01&quot;, locTimeZone = &quot;Europe/Zurich&quot;, main = &quot;Before/After Optimization&quot;, ylab = &quot;Energy Consumption \\n(kWh/month)&quot; ) # change theme (optional) plot &lt;- plot + ggthemes::theme_economist() # make plot interactive (optional) plotly &lt;- plotly::ggplotly(plot) # show plot plotly # save static plot as png ggsave(&quot;images/plotSeasonalXYBeforeAfter.png&quot;, plot) # save interactive plot as html library(htmlwidgets) htmlwidgets::saveWidget(plotly, &quot;plotlySeasonalXYBeforeAfter.html&quot;) 6.5.4 Discussion "],["decomposition-long-term.html", "6.6 Decomposition - Long term", " 6.6 Decomposition - Long term 6.6.1 Task tbd https://otexts.com/fpp2/tspatterns.html Hyndman, R.J., &amp; Athanasopoulos, G. (2018) Forecasting: principles and practice, 2nd edition, OTexts: Melbourne, Australia. OTexts.com/fpp2. Accessed on 6.6.2 Basis tbd monthly energy consumption meter values over 10 years 6.6.3 Solution Create a new script, copy/paste the following code and run it: library(dplyr) library(lubridate) library(plotly) library(ggplot2) library(forecast) # load csv file df &lt;- read.csv2(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatHeatAndHotWater.csv&quot;, stringsAsFactors=FALSE) # filter flat df &lt;- df %&gt;% select(timestamp, Adr02_energyHeat) colnames(df) &lt;- c(&quot;Time&quot;, &quot;meterValue&quot;) df$Time &lt;- parse_date_time(df$Time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) # calculate consumption value per month # pay attention, the value of 2010-02-01 00:00:00 represents the meter reading on february first, # so the consumption for february first is value(march) - value(february)! df &lt;- df %&gt;% mutate(value = lead(meterValue) - meterValue) # remove counter value column df &lt;- df %&gt;% select(-meterValue) %&gt;% na.omit() df[1,2] &lt;- 600 df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 12, start = min(year(df$Time))) df.decompose &lt;- df.ts[,1] %&gt;% stl(s.window = 7) df.decompose &lt;- df.decompose$time.series df.decompose &lt;- as.data.frame(df.decompose) df.decompose &lt;- cbind(df, df.decompose) data &lt;- as.data.frame(tidyr::pivot_longer(df.decompose, cols = -Time, names_to = &quot;Component&quot;, values_to = &quot;Value&quot;, values_drop_na = TRUE) ) data$component &lt;- as.factor(data$Component) data$component &lt;- factor(data$Component, c(&quot;value&quot;, &quot;trend&quot;, &quot;seasonal&quot;, &quot;remainder&quot;)) data$Value &lt;- round(data$Value, digits = 1) p &lt;- ggplot(data) + geom_path(aes(x = Time, y = Value ), color = &quot;black&quot;, alpha = 0.7) + facet_wrap(~component, ncol = 1, scales = &quot;free_y&quot;) + scale_x_datetime(date_breaks = &quot;years&quot; , date_labels = &quot;%Y&quot;) + theme_minimal() + theme(panel.spacing = unit(1, &quot;lines&quot;), legend.position = &quot;none&quot;) + labs(x = &quot;&quot;) + ggtitle(&quot;Time Series Decomposition over 10 Years&quot;) ggplotly(p) 6.6.4 Discussion tbd 6.6.5 See Also tbd "],["decomposition-short-term.html", "6.7 Decomposition - Short term", " 6.7 Decomposition - Short term 6.7.1 Task tbd https://otexts.com/fpp2/tspatterns.html Hyndman, R.J., &amp; Athanasopoulos, G. (2018) Forecasting: principles and practice, 2nd edition, OTexts: Melbourne, Australia. OTexts.com/fpp2. Accessed on 6.7.2 Basis tbd 15min energy consumption meter values over five days 6.7.3 Solution Create a new script, copy/paste the following code and run it: library(dplyr) library(lubridate) library(plotly) library(ggplot2) library(forecast) # change language to English, otherwise weekdays are in local language Sys.setlocale(&quot;LC_TIME&quot;, &quot;English&quot;) ## [1] &quot;English_United States.1252&quot; # load time series data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/eboBookEleMeter.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # rename column names colnames(df) &lt;- c(&quot;time&quot;, &quot;meterValue&quot;) df$time &lt;- parse_date_time(df$time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$time &lt;- force_tz(df$time, tzone = &quot;UTC&quot;) # uncomment to filter time range if necessary #df &lt;- df %&gt;% filter(Time &gt; &quot;2015-03-01 00:00:00&quot;, Time &lt; &quot;2015-04-01 00:00:00&quot;) # Fill missing values with NA grid.df &lt;- data.frame(time = seq(min(df$time, na.rm = TRUE), max(df$time, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% mutate(value = (meterValue - lag(meterValue))*4) %&gt;% select(-meterValue) %&gt;% na.omit() # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) # select time range df &lt;- df %&gt;% filter(time &gt;= as.POSIXct(&quot;2015-01-26 00:00:00&quot;, tz = &quot;UTC&quot;), time &lt; as.POSIXct(&quot;2015-01-31 00:00:00&quot;, tz = &quot;UTC&quot;)) # =========== Start of Code ================ df.ts &lt;- ts(df %&gt;% select(value) %&gt;% na.omit(), frequency = 96) df.decompose &lt;- df.ts[,1] %&gt;% stl(s.window = 193) df.decompose &lt;- df.decompose$time.series df.decompose &lt;- as.data.frame(df.decompose) df.decompose &lt;- cbind(df, df.decompose) data &lt;- as.data.frame(tidyr::pivot_longer(df.decompose, cols = -time, names_to = &quot;component&quot;, values_to = &quot;value&quot;, values_drop_na = TRUE) ) data$component &lt;- as.factor(data$component) data$component &lt;- factor(data$component, c(&quot;value&quot;, &quot;trend&quot;, &quot;seasonal&quot;, &quot;remainder&quot;)) # prepare data for plot componentTitles = c(&quot;Raw Data&quot;,&quot;Trend Component&quot;, &quot;Seasonal Component&quot;, &quot;Remainder&quot;) data &lt;- data %&gt;% mutate(component = recode(component, value = componentTitles[1], trend = componentTitles[2], seasonal = componentTitles[3], remainder = componentTitles[4]), value = round(data$value, digits = 1)) %&gt;% rename(Value = value, Time = time) p &lt;- ggplot(data) + geom_path(aes(x = Time, y = Value ), color = &quot;black&quot;, alpha = 0.7) + facet_wrap(~component, ncol = 1, scales = &quot;free_y&quot;) + scale_x_datetime(date_breaks = &quot;days&quot; , date_labels = &quot;%a\\n%d. %b\\n%H:%M&quot;) + theme_minimal() + theme(panel.spacing = unit(1, &quot;lines&quot;), legend.position = &quot;none&quot;) + labs(x = &quot;&quot;) + ggtitle(&quot;Time Series Decomposition over 5 days&quot;) ggplotly(p) 6.7.4 Discussion Trend The trend of a time series refers to the general direction in which the time series is moving. Time series can have a positive or a negative trend, but can also have no trend. Seasonal Pattern The seasonal component for time series data refers to its tendency to rise and fall at consistent frequencies. Remainder The remainder is whats left of the time series data after removing its trend, cycle, and seasonal components. It is the random fluctuation in the time series data that the above components cannot explain. 6.7.5 See Also tbd "],["heatmap-median-weeks.html", "6.8 Heatmap Median-Weeks", " 6.8 Heatmap Median-Weeks library(redutils) library(plotly) data &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) p &lt;- plotHeatmapMedianWeeks(data, locTimeZone = &quot;Europe/Zurich&quot;) # show the static plot p # create the interactive plot (optional, uncomment line) #ggplotly(p) "],["heatmap-calendar.html", "6.9 Heatmap Calendar", " 6.9 Heatmap Calendar library(ggplot2) library(ggTimeSeries) library(plotly) library(lubridate) library(dplyr) library(tidyquant) data &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) data &lt;- data[-nrow(data),] data$timestamp &lt;- parse_date_time(data$timestamp, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) data$day &lt;- as.Date(lubridate::floor_date(data$timestamp,&quot;day&quot;)) data &lt;- data %&gt;% select(-timestamp) data.plot &lt;- data %&gt;% dplyr::group_by(day) %&gt;% dplyr::mutate(calcVal = sum(value, na.rm = TRUE)) %&gt;% ungroup() %&gt;% select(-value) %&gt;% unique() p &lt;- ggplot_calendar_heatmap(data.plot, &quot;day&quot;, &quot;calcVal&quot;, monthBorderSize = 1, monthBorderColour = &quot;white&quot;, monthBorderLineEnd = &quot;square&quot;) + scale_fill_viridis_c(option = &quot;B&quot;) + theme_minimal() + theme(axis.title.y = element_text(colour = &quot;grey30&quot;, size = 10, face = &quot;plain&quot;), )+ labs(x = &quot;\\nMonth&quot;, y = &quot;Energy Consumption\\n(kWh/d)\\n &quot;, fill = &quot;Legend&quot;) + facet_wrap(~Year, ncol = 1) + ggtitle(&quot;Calendar Plot Energy Consumption\\n&quot;) p 6.9.1 Discussion Some findings: first two days in year minimal consumption 6th of April: Easter Monday 25th of May: Whitmonday (de: Pfingstmontag) More usage in August In November one Sunday with unusual high consumption On Fridays in general less consumption "],["building-energy-signature.html", "6.10 Building Energy Signature", " 6.10 Building Energy Signature 6.10.1 Task You want to create a scatter plot with the daily mean outside temperature on the x-axis the daily energy consumption on the y-axis points colored according to season 6.10.2 Basis Two separate csv files with time series data from the outside temperature and the energy data with unaligned time intervals Energy consumption time series from a energy meter with steadily increasing meter values 6.10.3 Solution After reading in the two time series the data has to get aggregated per day and then merged. Note that during the aggregation of the energy data you have to calculate the daily conspumption from the steadiliy increasing meter values as well. Create a new script, copy/paste the following code and run it: library(ggplot2) library(plotly) library(dplyr) library(redutils) library(lubridate) # load time series data and aggregate daily mean values dfOutsideTemp &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfOutsideTemp$time &lt;- parse_date_time(dfOutsideTemp$time, order = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) dfOutsideTemp$day &lt;- as.Date(cut(dfOutsideTemp$time, breaks = &quot;day&quot;)) dfOutsideTemp &lt;- dfOutsideTemp %&gt;% group_by(day) %&gt;% mutate(tempMean = mean(centralOutsideTemp)) %&gt;% ungroup() dfOutsideTemp &lt;- dfOutsideTemp %&gt;% select(day, tempMean) %&gt;% unique() %&gt;% na.omit() dfHeatEnergy &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralHeating.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfHeatEnergy &lt;- dfHeatEnergy %&gt;% select(time, energyHeatingMeter) %&gt;% na.omit() dfHeatEnergy$time &lt;- parse_date_time(dfHeatEnergy$time, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) dfHeatEnergy$day &lt;- as.Date(cut(dfHeatEnergy$time, breaks = &quot;day&quot;)) dfHeatEnergy &lt;- dfHeatEnergy %&gt;% group_by(day) %&gt;% mutate(energyMax = max(energyHeatingMeter)) %&gt;% ungroup() dfHeatEnergy &lt;- dfHeatEnergy %&gt;% select(day, energyMax) %&gt;% unique() %&gt;% na.omit() dfHeatEnergy &lt;- dfHeatEnergy %&gt;% mutate(energyCons = energyMax - lag(energyMax)) %&gt;% select(-energyMax) %&gt;% na.omit() # merge the data in a tidy format df &lt;- merge(dfOutsideTemp, dfHeatEnergy, by = &quot;day&quot;) # calculate season df &lt;- df %&gt;% mutate(season = redutils::getSeason(df$day)) # static chart with ggplot p &lt;- ggplot2::ggplot(df) + ggplot2::geom_point(aes(x = tempMean, y = energyCons, color = season, alpha = 0.1, text = paste(&quot;&lt;/br&gt;Date: &quot;, as.Date(df$day), &quot;&lt;/br&gt;Temp: &quot;, round(df$tempMean, digits = 1), &quot;\\u00B0C&quot;, &quot;&lt;/br&gt;Energy: &quot;, round(df$energyCons, digits = 0), &quot;kWh/d&quot;, &quot;&lt;/br&gt;Season: &quot;, df$season)) ) + scale_color_manual(values=c(&quot;#440154&quot;, &quot;#2db27d&quot;, &quot;#fde725&quot;, &quot;#365c8d&quot;)) + ggtitle(&quot;Building Energy Signature&quot;) + theme_minimal() + theme( legend.position=&quot;none&quot;, plot.title = element_text(hjust = 0.5) ) # interactive chart plotly::ggplotly(p, tooltip = c(&quot;text&quot;)) %&gt;% layout(xaxis = list(title = &quot;Outside temperature (\\u00B0C)&quot;, range = c(min(-5,min(df$tempMean)), max(35,max(df$tempMean))), zeroline = F), yaxis = list(title = &quot;Daily energy consumption (kWh/d)&quot;, range = c(-5, max(df$energyCons) + 10)), showlegend = TRUE ) %&gt;% plotly::config(displayModeBar = FALSE, displaylogo = FALSE) "],["daily-profiles-overview.html", "6.11 Daily Profiles - Overview", " 6.11 Daily Profiles - Overview library(ggplot2) library(dplyr) library(lubridate) library(redutils) library(ggplot2) library(plotly) # load time series data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/eboBookEleMeter.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # rename column names colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) df$timestamp &lt;- parse_date_time(df$timestamp, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$timestamp &lt;- force_tz(df$timestamp, tzone = &quot;UTC&quot;) # Fill missing values with NA grid.df &lt;- data.frame(timestamp = seq(min(df$timestamp, na.rm = TRUE), max(df$timestamp, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% mutate(value = (meterValue - lag(meterValue))*4) %&gt;% select(-meterValue) %&gt;% na.omit() # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) p &lt;- plotDailyProfilesOverview(df, locTimeZone = &quot;Europe/Zurich&quot;, main = &quot;Daily Profiles Overview by Weekday and Season&quot;, ylab = &quot;Energy Consumption (kWh/h)&quot;, col = &quot;black&quot;, confidence = 95.0) ggplotly(p) "],["daily-profiles-overlayed.html", "6.12 Daily Profiles - Overlayed", " 6.12 Daily Profiles - Overlayed # change language to English, otherwise weekdays are in local language Sys.setlocale(&quot;LC_TIME&quot;, &quot;English&quot;) ## [1] &quot;English_United States.1252&quot; library(plotly) library(dplyr) library(lubridate) # load time series data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/eboBookEleMeter.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # rename column names colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) df$timestamp &lt;- parse_date_time(df$timestamp, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$timestamp &lt;- force_tz(df$timestamp, tzone = &quot;UTC&quot;) # uncomment to filter time range if necessary #df &lt;- df %&gt;% filter(timestamp &gt; &quot;2015-03-01 00:00:00&quot;, timestamp &lt; &quot;2015-04-01 00:00:00&quot;) # Fill missing values with NA grid.df &lt;- data.frame(timestamp = seq(min(df$timestamp, na.rm = TRUE), max(df$timestamp, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% mutate(value = (meterValue - lag(meterValue))*4) %&gt;% select(-meterValue) %&gt;% na.omit() # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) # add metadata for later grouping and visualization purposes df$x &lt;- hour(df$timestamp) + minute(df$timestamp)/60 + second(df$timestamp) / 3600 df$weekday &lt;- weekdays(df$timestamp) df$weekday &lt;- factor(df$weekday, c(&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;, &quot;Sunday&quot;)) df$day &lt;- as.Date(df$timestamp, format = &quot;%Y-%m-%d %H:%M:%S&quot;) df &lt;- df %&gt;% mutate(value = ifelse(x == 0.00, NA, df$value)) # plot graph with all time series rangeX &lt;- seq(0,24,0.25) maxValue &lt;- max(df$value, na.rm = TRUE)*1.05 df %&gt;% highlight_key(~day) %&gt;% plot_ly(x=~x, y=~value, color=~weekday, type=&quot;scatter&quot;, mode=&quot;lines&quot;, line = list(width = 1), alpha = 0.15, colors = &quot;dodgerblue4&quot;, text = ~day, hovertemplate = paste(&quot;Time: &quot;, format(df$timestamp, &quot;%H:%M&quot;), &quot;&lt;br&gt;Date: &quot;, format(df$timestamp, &quot;%Y-%m-%d&quot;), &quot;&lt;br&gt;Value: %{y:.0f}&quot;)) %&gt;% # workaround with add_trace to have fixed y axis when selecting a dedicated day add_trace(x = 0, y = 0, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% add_trace(x = 24, y = maxValue, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% layout(title = &quot;Daily Profiles - Overlayed&quot;, showlegend = TRUE, xaxis = list( title = &quot;Hour of day&quot;, range = rangeX, tickvals = list(0, 3, 6, 9, 12, 15, 18, 21), showline=TRUE ), yaxis = list( title = &quot;Power (kW)&quot;, range = c(0, maxValue) ) ) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;, color = &quot;orange&quot;, opacityDim = 1.0, selected = attrs_selected(showlegend = FALSE)) %&gt;% # this hides elements in the legend plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE) Next we want to create an overview with the mean values for each 15 minute slot per day. Append the following code at the end of your script: # Calculate Mean value for all 15 minutes for each weekday df2 &lt;- df %&gt;% group_by(weekday, x) %&gt;% mutate(dayTimeMean = mean(value)) %&gt;% ungroup() # shrink data frame df2 &lt;- df2 %&gt;% select(x, weekday, timestamp, dayTimeMean) %&gt;% unique() %&gt;% na.omit() %&gt;% arrange(weekday, x) # plot graph with mean values maxValMean &lt;- max(df2$dayTimeMean, na.rm = TRUE)*1.05 df2 %&gt;% highlight_key(~weekday) %&gt;% plot_ly(x=~x, y=~dayTimeMean, color=~weekday, type=&quot;scatter&quot;, mode=&quot;lines&quot;, alpha = 0.25, colors = &quot;dodgerblue4&quot;, text = ~weekday, hovertemplate = paste(&quot;Time: &quot;, format(df2$timestamp, &quot;%H:%M&quot;), &quot;&lt;br&gt;Mean: %{y:.0f}&quot;)) %&gt;% # workaround with add_trace to have fixed y axis when selecting a dedicated day add_trace(x = 0, y = 0, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% add_trace(x = 24, y = maxValMean, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% layout(title = &quot;Superimposed Mean Profiles of Power Consumption per 15 min&quot;, showlegend = TRUE, xaxis = list( title = &quot;Hour of day&quot;, tickvals = list(0, 3, 6, 9, 12, 15, 18, 21) ), yaxis = list( title = &quot;Power (kW)&quot;, range = c(0, maxValMean) ) ) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;, color = &quot;orange&quot;, opacityDim = 0.7, selected = attrs_selected(showlegend = FALSE)) %&gt;% # this hides elements in the legend plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE) "],["daily-profiles-decompose.html", "6.13 Daily Profiles - Decompose", " 6.13 Daily Profiles - Decompose # change language to English, otherwise weekdays are in local language Sys.setlocale(&quot;LC_TIME&quot;, &quot;English&quot;) ## [1] &quot;English_United States.1252&quot; library(plotly) library(dplyr) library(lubridate) # load time series data df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/eboBookEleMeter.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # rename column names colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) df$timestamp &lt;- parse_date_time(df$timestamp, orders = &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) df$timestamp &lt;- force_tz(df$timestamp, tzone = &quot;UTC&quot;) # uncomment to filter time range if necessary #df &lt;- df %&gt;% filter(timestamp &gt; &quot;2015-03-01 00:00:00&quot;, timestamp &lt; &quot;2015-04-01 00:00:00&quot;) # Fill missing values with NA grid.df &lt;- data.frame(timestamp = seq(min(df$timestamp, na.rm = TRUE), max(df$timestamp, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% mutate(value = (meterValue - lag(meterValue))*4) %&gt;% select(-meterValue) %&gt;% na.omit() # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) # add metadata for later grouping and visualization purposes df$x &lt;- hour(df$timestamp) + minute(df$timestamp)/60 + second(df$timestamp) / 3600 df$weekday &lt;- weekdays(df$timestamp) df$weekday &lt;- factor(df$weekday, c(&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;, &quot;Sunday&quot;)) df &lt;- df %&gt;% mutate(value = ifelse(x == 0.00, NA, df$value)) # Calculate Mean value for all 15 minutes for each weekday df &lt;- df %&gt;% group_by(weekday, x) %&gt;% mutate(dayTimeMean = mean(value)) %&gt;% ungroup() # shrink data frame df &lt;- df %&gt;% select(x, weekday, timestamp, dayTimeMean) %&gt;% unique() %&gt;% na.omit() %&gt;% arrange(weekday, x) # plot graph with mean values maxValMean &lt;- max(df$dayTimeMean, na.rm = TRUE)*1.05 df %&gt;% highlight_key(~weekday) %&gt;% plot_ly(x=~x, y=~dayTimeMean, color=~weekday, type=&quot;scatter&quot;, mode=&quot;lines&quot;, alpha = 0.25, colors = &quot;dodgerblue4&quot;, text = ~weekday, hovertemplate = paste(&quot;Time: &quot;, format(df$timestamp, &quot;%H:%M&quot;), &quot;&lt;br&gt;Mean: %{y:.0f}&quot;)) %&gt;% # workaround with add_trace to have fixed y axis when selecting a dedicated day add_trace(x = 0, y = 0, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% add_trace(x = 24, y = maxValMean, type = &quot;scatter&quot;, showlegend = FALSE, opacity=0) %&gt;% layout(title = &quot;Daily Profiles - Mean&quot;, showlegend = TRUE, xaxis = list( title = &quot;Hour of day&quot;, tickvals = list(0, 3, 6, 9, 12, 15, 18, 21) ), yaxis = list( title = &quot;Power (kW)&quot;, range = c(0, maxValMean) ) ) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;, color = &quot;orange&quot;, opacityDim = 0.7, selected = attrs_selected(showlegend = FALSE)) %&gt;% # this hides elements in the legend plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE) "],["daily-profiles-decomposed.html", "6.14 Daily Profiles - Decomposed", " 6.14 Daily Profiles - Decomposed library(plotly) library(redutils) data &lt;- readRDS(system.file(&quot;sampleData/eboBookEleMeter.rds&quot;, package = &quot;redutils&quot;)) p &lt;- plotDailyProfilesDecomposed(data, locTimeZone = &quot;Europe/Zurich&quot;) ggplotly(p) "],["mollier-hx-diagram.html", "6.15 Mollier hx Diagram", " 6.15 Mollier hx Diagram 6.15.1 Task You want to plot a mollier h-x diagram with scatter plot of temperature- and humidity sensor data (mean values per day) points colored according to season comfort zone 6.15.2 Basis A csv file with time series from multiple temperature and humidity sensors in °C and %rH 6.15.3 Solution The sensor data is not in a constant intervall and not yet aggregated. So after reading in the time series the data has to get filtered and aggregated per day. Finally use the plot function mollierHxDiagram from the redutils package (R Energy Data Utilities). If you have not yet installed this package, proceed as follows: install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;hslu-ige-laes/redutils&quot;) Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) # read and print data data &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) # select temperature and humidity and remove empty cells data &lt;- data %&gt;% select(time, FlatA_Temp, FlatA_Hum) %&gt;% na.omit() # create column with day for later grouping data$time &lt;- parse_date_time(data$time, &quot;YmdHMS&quot;, tz = &quot;Europe/Zurich&quot;) data$day &lt;- as.Date(cut(data$time, breaks = &quot;day&quot;)) # calculate daily mean of temperature and humidity data &lt;- data %&gt;% group_by(day) %&gt;% mutate(tempMean = mean(as.numeric(FlatA_Temp)), humMean = mean(as.numeric(FlatA_Hum)) ) %&gt;% ungroup() # shrink down to daily values and remove rows with empty values data &lt;- data %&gt;% select(day, tempMean, humMean) %&gt;% unique() %&gt;% na.omit() # plot mollier hx diagram plotMollierHx(data) "],["sia-180-thermal-comfort.html", "6.16 SIA 180 Thermal Comfort", " 6.16 SIA 180 Thermal Comfort 6.16.1 Task You want to plot a diagram like the one from the SIA 180:2014 which showes scatter plot of indoor- and outdoor temperature sensor data (indoor mean of day, outdoor mean of last 48 hours) points colored according to season different comfort lines 6.16.2 Basis A csv file with time series from multiple temperature and humidity sensors in °C A csv file with the outdoor temperature 6.16.3 Solution The sensor data is not in a constant intervall and not yet aggregated. So after reading in the time series the data has to get filtered, aggregated per day and merged. Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(zoo) library(plotly) # load time series data and aggregate mean values dfTempOa &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/centralOutsideTemp.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfTempOa$time &lt;- parse_date_time(dfTempOa$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) dfTempOa$hour &lt;- cut(dfTempOa$time, breaks = &quot;hour&quot;) dfTempOa &lt;- dfTempOa %&gt;% group_by(hour) %&gt;% mutate(tempMean = mean(centralOutsideTemp)) %&gt;% ungroup() %&gt;% select(time, tempMean) %&gt;% unique() # Fill missing values with NA grid.df &lt;- data.frame(time = seq(min(dfTempOa$time, na.rm = TRUE), max(dfTempOa$time, na.rm = TRUE), by = &quot;hour&quot;)) dfTempOa &lt;- merge(dfTempOa, grid.df, all = TRUE) dfTempOa &lt;- dfTempOa %&gt;% mutate(tempOa = rollmean(tempMean, 48, fill = NA, align = &quot;right&quot;)) dfTempOa &lt;- dfTempOa %&gt;% select(time, tempOa) %&gt;% unique() %&gt;% na.omit() dfTempR &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatTempHum.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) dfTempR$time &lt;- parse_date_time(dfTempR$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) # select temperature and humidity and remove empty cells dfTempR &lt;- dfTempR %&gt;% select(time, FlatA_Temp) %&gt;% na.omit() dfTempR$hour &lt;- cut(dfTempR$time, breaks = &quot;hour&quot;) dfTempR &lt;- dfTempR %&gt;% group_by(hour) %&gt;% mutate(tempR = mean(FlatA_Temp)) %&gt;% ungroup() %&gt;% select(time, tempR) %&gt;% unique() # Fill missing values with NA grid.df &lt;- data.frame(time = seq(min(dfTempR$time, na.rm = TRUE), max(dfTempR$time, na.rm = TRUE), by = &quot;hour&quot;)) dfTempR &lt;- merge(dfTempR, grid.df, all = TRUE) data &lt;- merge(dfTempR, dfTempOa, all = TRUE) %&gt;% unique() %&gt;% na.omit() data$season &lt;- redutils::getSeason(data$time) # plot diagram # axis properties minx &lt;- floor(min(0, min(data$tempOa))) maxx &lt;- ceiling(max(28, max(data$tempOa))) miny &lt;- floor(min(21.0,min(data$tempR)))-1 maxy &lt;- ceiling(max(32.0,max(data$tempR)))+1 # line setpoint heat df.heatSp &lt;- data.frame(tempOa = c(minx, 19, 23.5, maxx), tempR = c(20.5, 20.5, 22, 22)) # line setpoint cool according to SIA 180:2014 Fig. 4 df.coolSp1 &lt;- data.frame(tempOa = c(minx, 12, 17.5, maxx),tempR = c(24.5, 24.5, 26.5, 26.5)) # line setpoint cool according to SIA 180:2014 Fig. 3 df.coolSp2 &lt;- data.frame(tempOa = c(minx, 10, maxx),tempR = c(25, 25, 0.33 * maxx + 21.8)) data %&gt;% plot_ly(showlegend = TRUE) %&gt;% add_lines(data = df.coolSp2, x = ~tempOa, y = ~tempR, name = &quot;Upper limit SIA 180 passive cooling&quot;, opacity = 0.7, color = &quot;#FDE725FF&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Upper limit SIA 180 passive cooling&quot;, &quot;&lt;br /&gt;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa) ) ) %&gt;% add_lines(data = df.coolSp1, x = ~tempOa, y = ~tempR, name = &quot;Upper limit SIA 180 active cooling&quot;, opacity = 0.7, color = &quot;#1E9B8AFF&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Upper limit SIA 180 active cooling&quot;, &quot;&lt;br /&gt;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa) ) ) %&gt;% add_lines(data = df.heatSp, x = ~tempOa, y = ~tempR, name = &quot;Lower Limit SIA 180&quot;, opacity = 0.7, color = &quot;#440154FF&quot;, hoverinfo = &quot;text&quot;, text = ~ paste(&quot;Lower Limit SIA 180&quot;, &quot;&lt;br /&gt;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa) ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Spring&quot;), x = ~tempOa, y = ~tempR, name = &quot;Spring&quot;, marker = list(color = &quot;#2db27d&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Summer&quot;), x = ~tempOa, y = ~tempR, name = &quot;Summer&quot;, marker = list(color = &quot;#febc2b&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Fall&quot;), x = ~tempOa, y = ~tempR, name = &quot;Fall&quot;, marker = list(color = &quot;#440154&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_markers(data = data %&gt;% filter(season == &quot;Winter&quot;), x = ~tempOa, y = ~tempR, name = &quot;Winter&quot;, marker = list(color = &quot;#365c8d&quot;, opacity = 0.1), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;TempR: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempR), &quot;&lt;br /&gt;TempOa: &quot;, sprintf(&quot;%.1f \\u00B0C&quot;, tempOa), &quot;&lt;br /&gt;Date: &quot;, time, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% layout( xaxis = list(title = &quot;Moving average outdoor temperature in \\u00B0C over 48 hours&quot;, range = c(minx, maxx), zeroline = FALSE, tick0 = minx, dtick = 2, titlefont = list(size = 14, color = &quot;darkgrey&quot;)), yaxis = list(title = &quot;Room Temperature in \\u00B0C&quot;, range = c(miny, maxy), dtick = 1, titlefont = list(size = 14, color = &quot;darkgrey&quot;)), hoverlabel = list(align = &quot;left&quot;), margin = list(l = 80, t = 50, r = 50, b = 10), legend = list(orientation = &#39;h&#39;, x = 0.0, y = -0.3) ) %&gt;% plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE, toImageButtonOptions = list( format = &quot;svg&quot; ) ) 6.16.4 Discussion tbd 6.16.5 See Also tbd "],["electricity-household.html", "6.17 Electricity Household", " 6.17 Electricity Household 6.17.1 Task You want to plot an electricity consumption diagram which shows upper plot with daily energy consumption in kWh/day lower plot with standby-losses in Watts Additionaly we would like to see the consumption of an average Swiss household. 6.17.2 Basis A csv file with time series of an electric meter in 15 minute interval. 6.17.3 Solution Create a new script, copy/paste the following code and run it: library(redutils) library(dplyr) library(lubridate) library(zoo) library(plotly) # load time series data and aggregate mean values df &lt;- read.csv(&quot;https://github.com/hslu-ige-laes/edar/raw/master/sampleData/flatElectricity.csv&quot;, stringsAsFactors=FALSE, sep =&quot;;&quot;) df$time &lt;- parse_date_time(df$time, order = &quot;YmdHMS&quot;, tz = &quot;UTC&quot;) # select room df &lt;- df %&gt;% select(time, FlatC_Ele) # rename columns colnames(df) &lt;- c(&quot;timestamp&quot;, &quot;meterValue&quot;) # filter timerange df &lt;- df %&gt;% filter(timestamp &gt; &quot;2019-07-01&quot;) # Fill missing values with NA grid.df &lt;- data.frame(timestamp = seq(min(df$timestamp, na.rm = TRUE), max(df$timestamp, na.rm = TRUE), by = &quot;15 mins&quot;)) df &lt;- merge(df, grid.df, all = TRUE) # convert steadily counting energy meter value from kWh to power in kW df &lt;- df %&gt;% mutate(value = (meterValue - lag(meterValue))) %&gt;% select(-meterValue) # remove negative values which occur beause of change summer/winter time df &lt;- df %&gt;% filter(value &gt;= 0) # determine date related parameters for later filtering df$day &lt;- as.Date(df$time, tz = &quot;UTC&quot;) df$week &lt;- lubridate::week(df$time) df$month &lt;- lubridate::month(df$time) df$year &lt;- lubridate::year(df$time) # data cleansing # tag NA df &lt;- df %&gt;% mutate(deleteNA = ifelse(is.na(value),1,0)) # tag values below 0 and higher than 9.2 kW df &lt;- df %&gt;% mutate(deleteHiLoVal = ifelse(value &gt; 9.2,1, ifelse(value &lt; 0,1,0))) # Assumption max. fuse 40 ampere (higher fuses for single family houses) # this results in continuous power 9.2 kW # this results in an hourly consumption of 9.2kWh # over 24h = approx. 221 kWh max. consumption per day # tag whole days which have one or more values to delete, keep only whole valid days df &lt;- df %&gt;% group_by(day) %&gt;% mutate(delete = sum(deleteNA, na.rm = TRUE) + sum(deleteHiLoVal, na.rm = TRUE)) df &lt;- df %&gt;% ungroup() # delete full days with invalid data df &lt;- df %&gt;% filter(delete == 0) %&gt;% select(-deleteNA, -deleteHiLoVal, -delete) # determine season for later filtering df &lt;- df %&gt;% mutate(season = redutils::getSeason(timestamp)) # calculate sum and min per day df &lt;- df %&gt;% dplyr::group_by(day) %&gt;% dplyr::mutate(sum = sum(value)) df &lt;- df %&gt;% dplyr::group_by(day) %&gt;% dplyr::mutate(min = min(value)*1000*4) df &lt;- df %&gt;% ungroup() df &lt;- df %&gt;% dplyr::select(day, sum, min, season) %&gt;% unique() df &lt;- df %&gt;% dplyr::mutate(ravgUsage = zoo::rollmean(x=sum, 7, fill = NA)) df &lt;- df %&gt;% dplyr::mutate(rminStandby = -1 * zoo::rollmaxr(x = -1 * min, 7, fill = NA)) typEleConsVal &lt;- redutils::getTypEleConsHousehold(occupants = 2, rooms = 3.5, bldgType = &quot;multi&quot;, laundry = &quot;hotWaterSupply&quot;)/365 # Plot main = &quot;Electricity consumption private household&quot; minY &lt;- 0 maxYUsage &lt;- max(df %&gt;% select(sum), na.rm=TRUE) maxYUsage &lt;- max(maxYUsage, typEleConsVal/365) maxYStandby &lt;- max(max(df %&gt;% select(min), na.rm=TRUE), 0.25*maxYUsage/24*1000) minX &lt;- min(df$day) maxX &lt;- max(df$day) averageUsage &lt;- mean(df$sum, na.rm=TRUE) averageStandby &lt;- mean(df$rminStandby, na.rm=TRUE) shareStandby &lt;- nrow(df %&gt;% select(sum) %&gt;% na.omit()) * averageStandby * 24 / (1000 * sum(df$sum, na.rm=TRUE)) * 100 # legend l &lt;- list( orientation = &quot;h&quot;, tracegroupgap = &quot;20&quot;, font = list(size = 8), xanchor = &quot;center&quot;, x = 0.5, itemclick = FALSE ) fig1 &lt;- df %&gt;% plot_ly(x = ~day, showlegend = TRUE) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Spring&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Spring&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#2db27d&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;daily usage: &quot;, sprintf(&quot;%.1f kWh/d&quot;, sum), &quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Summer&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Summer&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#febc2b&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Fall&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Fall&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#440154&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df %&gt;% filter(season == &quot;Winter&quot;), type = &quot;bar&quot;, y = ~sum, name = &quot;Winter&quot;, legendgroup = &quot;group1&quot;, marker = list(color = &quot;#365c8d&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df, type = &quot;scatter&quot;, mode = &quot;markers&quot;, y = ~ravgUsage, name = &quot;Average Cons. (7 days)&quot;, legendgroup = &quot;group2&quot;, marker = list(color = &quot;orange&quot;, opacity = 0.4, symbol = &quot;circle&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~averageUsage, yend = ~averageUsage, name = &quot;Average Cons. Total&quot;, legendgroup = &quot;group2&quot;, line = list(color = &quot;orange&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.1f kWh/d&quot;, ravgUsage), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~averageStandby*24/1000, yend = ~averageStandby*24/1000, name = &quot;Average Standby Total&quot;, legendgroup = &quot;group3&quot;, showlegend = FALSE, line = list(color = &quot;black&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;Average standby power: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;equals to daily energy: &quot;, sprintf(&quot;%.1f kWh&quot;, averageStandby*24/1000), &quot;&lt;br /&gt;Standby percent of total cons.: &quot;, sprintf(&quot;%.0f %%&quot;, shareStandby) ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~typEleConsVal, yend = ~typEleConsVal, name = &quot;typical household&quot;, legendgroup = &quot;group4&quot;, line = list(color = &quot;#481567FF&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;typical household: &quot;, sprintf(&quot;%.0f kWh/year&quot;, typEleConsVal*365), &quot;&lt;br /&gt;equals to daily energy: &quot;, sprintf(&quot;%.1f kWh/day&quot;, typEleConsVal), &quot;&lt;br /&gt;consumption of current flat: &quot;, sprintf(&quot;%.1f kWh/day&quot;, averageUsage) ) ) %&gt;% add_annotations( x = minX, y = typEleConsVal, text = paste0(&quot;typical comparable household &quot;, sprintf(&quot;%.1f kWh/d&quot;, typEleConsVal)), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = 100, ay = -20, font = list(color = &quot;#481567FF&quot;) ) %&gt;% add_annotations( x = maxX, y = averageUsage, text = paste0(&quot;Average consumption &quot;, sprintf(&quot;%.1f kWh/d&quot;, averageUsage)), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = -100, ay = -60, font = list(color = &quot;orange&quot;) ) %&gt;% add_annotations( x = maxX, y = averageStandby*24/1000, text = paste0(sprintf(&quot;%.1f %%&quot;, shareStandby), &quot; of the consumption are standby-losses&quot;), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = -160, ay = -15, font = list(color = &quot;black&quot;) ) %&gt;% layout( title = main, xaxis = list( title = &quot;&quot; ), yaxis = list(title = &quot;Consumption&lt;br&gt;(kWh/d)&quot;, range = c(minY, maxYUsage), titlefont = list(size = 14, color = &quot;darkgrey&quot;)), hoverlabel = list(align = &quot;left&quot;), margin = list(l = 80, t = 50, r = 50, b = 10), legend = l ) fig2 &lt;- df %&gt;% plot_ly(x = ~day, showlegend = TRUE) %&gt;% add_trace(data = df, type = &quot;bar&quot;, y = ~min, name = &quot;Daily standby-losses&quot;, legendgroup = &quot;group3&quot;, marker = list(color = &quot;darkgrey&quot;, opacity = 0.2), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;daily standby: &quot;, sprintf(&quot;%.0f W&quot;, min), &quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.0f W&quot;, rminStandby), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_trace(data = df, type = &quot;scatter&quot;, mode = &quot;markers&quot;, y = ~rminStandby, name = &quot;Average Standby (7 days)&quot;, legendgroup = &quot;group3&quot;, marker = list(color = &quot;darkgrey&quot;, opacity = 0.5, symbol = &quot;circle&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;daily standby: &quot;, sprintf(&quot;%.0f W&quot;, min), &quot;&lt;br /&gt;rolling average: &quot;, sprintf(&quot;%.0f W&quot;, rminStandby), &quot;&lt;br /&gt;Average vis. points: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;Date: &quot;, day, &quot;&lt;br /&gt;Season: &quot;, season ) ) %&gt;% add_segments(x = ~minX, xend = ~maxX, y = ~averageStandby, yend = ~averageStandby, name = &quot;Average Standby Total&quot;, legendgroup = &quot;group3&quot;, line = list(color = &quot;black&quot;, opacity = 1.0, dash = &quot;dot&quot;), hoverinfo = &quot;text&quot;, text = ~ paste(&quot;&lt;br /&gt;Average standby power: &quot;, sprintf(&quot;%.0f W&quot;, averageStandby), &quot;&lt;br /&gt;equals to daily energy: &quot;, sprintf(&quot;%.1f kWh&quot;, averageStandby*24/1000), &quot;&lt;br /&gt;Standby percent of total cons.: &quot;, sprintf(&quot;%.0f %%&quot;, shareStandby) ) ) %&gt;% add_annotations( x = maxX, y = averageStandby, text = paste0(sprintf(&quot;%.0f W&quot;, averageStandby), &quot; standby-losses on average&quot;), xref = &quot;x&quot;, yref = &quot;y&quot;, showarrow = TRUE, arrowhead = 7, ax = -60, ay = -20, font = list(color = &quot;black&quot;) ) %&gt;% layout( xaxis = list( title = &quot;&quot; ), yaxis = list(title = &quot; Standby&lt;br&gt;(W)&quot;, range = c(minY, maxYStandby), titlefont = list(size = 14, color = &quot;darkgrey&quot;), legend = list(orientation = &#39;h&#39;)), legend = l ) # calculate ratio which is visual representative for comparison # ratio &lt;- 1/maxYUsage * maxYStandby * 24 / 1000 ratio &lt;- 0.3 fig &lt;- subplot(fig1, fig2, nrows = 2, shareX = TRUE, heights = c(1-ratio, ratio), titleY = TRUE) %&gt;% plotly::config(modeBarButtons = list(list(&quot;toImage&quot;)), displaylogo = FALSE, toImageButtonOptions = list( format = &quot;svg&quot; ) ) fig 6.17.4 Discussion tbd 6.17.5 See Also tbd "],["packages.html", "A Packages in R", " A Packages in R Many functions of R are not pre-installed and must be loaded manually. R packages are similar to libraries in C, Python etc. An R package bundles useful functions, help files and data sets. You can use these functions within your own R code once you load the package. The following chapters describe how to install, load, update and use packages. "],["installing-a-package.html", "A.1 Installing a Package", " A.1 Installing a Package The easiest way to install an R Package is to use the RStudio tab Packages: Figure A.1: Install packages via RStudio GUI Click on the Packages tab Click on Install next to Update Type the name of the package under Packages, in this case type ggplot2 Click Install This will search for the package ggplot specified on a server (the so-called CRAN website). If the package exists, it will be downloaded to a library folder on your computer. Here R can access the package in future R sessions without having to reinstall it. An other way is to use the install.packages function. Open R (if already opened please close all projects) and type the following at the command line: install.packages(&quot;ggplot2&quot;) If you want to install a package directly from github, the package devtools must be installed first: install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;hslu-ige-laes/redutils&quot;) "],["loading-a-package.html", "A.2 Loading a Package", " A.2 Loading a Package If you have installed a package, its functions are not yet available in your R project. To use an R package in your sript, you must load it with the following command: install.packages(&quot;ggplot2&quot;) "],["upgrading-packages.html", "A.3 Upgrading Packages", " A.3 Upgrading Packages R packages are often constantly updated on CRAN or GitHub, so you may want to update them once in a while with: update.packages(ask = FALSE) "]]
